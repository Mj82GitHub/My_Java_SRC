/*
 * Copyright (c) 01.2018
 */

package Triangulation;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;

import Triangulation.Decompositor.Scaning;
import Triangulation.Edge.Intersect;
import Triangulation.Mj_Point.Point_position;
import Triangulation.Mj_Polygon;
import Triangulation.Decompositor;
import Triangulation.Mj_List;
import Triangulation.Mj_ListVertex;
import Triangulation.Mj_Vertex;
import Triangulation.Mj_Point;
import Triangulation.Mj_Vertex.Rotation;

/**
 * Класс для триангуляции любых по форме полигонов (включая полигоны, содержащие внутренние области).
 * 
 * @author Mikhail Kushnerov (mj82)
 */

public class Triangulation extends JFrame {
	
	private static final long serialVersionUID = 1L;
	
	//При проекции Меркатора на сферу
	public static final double R = 6378137.0000000; // Радиус земли

	//При расщеплении полигона, чтобы небыло двух одинаковых ребер, при сравнении, одно из них 
	// смещаем на эту величину
	public static double delta = 0.000001; 
	// Габаритный параметр для рассчета стороны треугольника при триангуляции
	public static double h = 1;

	// Используются для масштабирования и вывода объекта карты на экран
	public static int minLon;
	public static int maxLon;
	public static int minLat;
	public static int maxLat;
	// Флаг, используется для того, чтобы обозначить первую инициализацию вышестоящих переменных
	public static boolean isFirst = false;
	
	// Оригинальные координаты до добавления delta и поворота при декомпозиции
	public static HashMap<Double, Double> org_coords = new HashMap<Double, Double>();
	// Используется при объединении внутреннего полигона и внешнего
	// Хранит точки ребра разрезания
	public static ArrayList<Mj_Vertex> useOuterVertexes; 
	
	private Decompositor decompositor = new Decompositor(); // Разбивает полигон на монотонные
	private Mj_Polygon outer_polygon; // Внешний полигон до декомпозиции на монотонные полигоны
	private Mj_List<Mj_Polygon> monotone_polygons; // Список монотонных полигонов после декомпозиции внешнего полигона
	// Список треугольников после триангуляции монотонных полигонов
	private Mj_List<Mj_Polygon> triangles = new Mj_List<Mj_Polygon>(); 
	
	// После объединения внутренних полигонов с одинаковыми сторонами могут возникать
	// дополнительные внешние полигоны
	public static Mj_List<Mj_Polygon> outerPolysAfterUnionInnersPolys = new Mj_List<Mj_Polygon>();

//////	
	// Класс содержит методы предназначенные для взаимодействия с оконной системой
	// конкретной платформы
	private Toolkit toolkit;
	// Размер окна граф. редактора
	private Dimension screenSize;
	private PaintPanel pp;

	private double[] outer1 = new double[] {
		20.5004924	,
		54.6647489	,
		20.5004913	,
		54.6647826	,
		20.5004554	,
		54.664782	,
		20.500453	,
		54.6648275	,
		20.5005503	,
		54.6648292	,
		20.500551	,
		54.6648157	,
		20.5006245	,
		54.6648164	,
		20.500625	,
		54.6648013	,
		20.5007508	,
		54.6648026	,
		20.5007508	,
		54.6648192	,
		20.5008127	,
		54.6648192	,
		20.5008127	,
		54.6648032	,
		20.5008984	,
		54.664804	,
		20.5008996	,
		54.6648446	,
		20.5009899	,
		54.6648436	,
		20.5009899	,
		54.6648597	,
		20.5010518	,
		54.6648597	,
		20.5010518	,
		54.664843	,
		20.5011776	,
		54.6648418	,
		20.5011781	,
		54.6648569	,
		20.5012516	,
		54.6648561	,
		20.5012523	,
		54.6648696	,
		20.5013496	,
		54.6648679	,
		20.5013472	,
		54.6648225	,
		20.5013113	,
		54.6648231	,
		20.5013097	,
		54.6647715	,
		20.5013472	,
		54.6647715	,
		20.5013472	,
		54.6647315	,
		20.5012592	,
		54.6647315	,
		20.5012592	,
		54.6647513	,
		20.5012439	,
		54.6647515	,
		20.5012437	,
		54.6647417	,
		20.5010018	,
		54.6647439	,
		20.5010021	,
		54.6647539	,
		20.5009044	,
		54.6647549	,
		20.5009057	,
		54.6647145	,
		20.5008006	,
		54.6647134	,
		20.5008008	,
		54.6647035	,
		20.5005589	,
		54.6647012	,
		20.5005587	,
		54.664711	,
		20.5005434	,
		54.6647108	,
		20.5005434	,
		54.6647071	,
		20.5005463	,
		54.6647053	,
		20.5005434	,
		54.6646991	,
		20.5005434	,
		54.6646911	,
		20.5005396	,
		54.6646911	,
		20.5005391	,
		54.6646901	,
		20.5005434	,
		54.6646901	,
		20.5005444	,
		54.6646307	,
		20.5005639	,
		54.6646307	,
		20.5005639	,
		54.6644573	,
		20.5005474	,
		54.6644573	,
		20.5005494	,
		54.6643416	,
		20.5005735	,
		54.6643417	,
		20.5005769	,
		54.6641683	,
		20.5005525	,
		54.6641681	,
		20.5005535	,
		54.6641094	,
		20.5003988	,
		54.6641085	,
		20.5003978	,
		54.6641671	,
		20.5003752	,
		54.664167	,
		20.5003718	,
		54.6643404	,
		20.5003947	,
		54.6643406	,
		20.5003927	,
		54.6644573	,
		20.5003718	,
		54.6644573	,
		20.5003718	,
		54.6646307	,
		20.5003897	,
		54.6646307	,
		20.5003887	,
		54.6646892	,
		20.5004627	,
		54.6646896	,
		20.5004632	,
		54.6646911	,
		20.5004554	,
		54.6646911	,
		20.5004554	,
		54.664731	,
		20.5004761	,
		54.664731	,
		20.5004774	,
		54.664735	};
	private double[] outer2 = new double[] {
				20.5221448	,
				54.7209122	,
				20.5223661	,
				54.7209098	,
				20.5223822	,
				54.7210655	,
				20.5228504	,
				54.7210392	,
				20.5228123	,
				54.720782	,
				20.5227086	,
				54.7206869	,
				20.5225374	,
				54.7206978	,
				20.5225267	,
				54.7206406	,
				20.5221869	,
				54.7206529	,
				20.5222036	,
				54.7207327	,
				20.5219819	,
				54.7207275	,
				20.5219613	,
				54.7210222	,
				20.5219006	,
				54.7210207	,
				20.5218902	,
				54.7211703	,
				20.5219773	,
				54.7211723	,
				20.5219686	,
				54.7212968	,
				20.5219993	,
				54.7212976	,
				20.5219946	,
				54.7213654	,
				20.52217	,
				54.7213695	,
				20.5221743	,
				54.7213083	,
				20.5222111	,
				54.7213092	,
				20.5222352	,
				54.7209653	,
				20.5221413	,
				54.7209631	};
			
				private double[][] inners2 = new double[][] {{
				20.5222717	,
				54.7208886	,
				20.5222758	,
				54.7208306	,
				20.522322	,
				54.7208317	,
				20.5224765	,
				54.7208249	,
				20.5224841	,
				54.720886	}};
	
	
	private double[] outer3 = new double[] {
		12.4582108	,
		41.9027585	,
		12.4582325	,
		41.9027251	,
		12.4582757	,
		41.9026448	,
		12.4583071	,
		41.9025689	,
		12.458332	,
		41.9024876	,
		12.4583564	,
		41.9023649	,
		12.4583653	,
		41.9022581	,
		12.4583629	,
		41.902174	,
		12.4583573	,
		41.9020788	,
		12.4583444	,
		41.9019924	,
		12.4583265	,
		41.9019228	,
		12.4583088	,
		41.9018745	,
		12.4582866	,
		41.9018296	,
		12.4582637	,
		41.901775	,
		12.4582357	,
		41.9017826	,
		12.4582221	,
		41.9017863	,
		12.4581589	,
		41.9018034	,
		12.4581454	,
		41.9018071	,
		12.4581194	,
		41.9018141	,
		12.4580903	,
		41.901822	,
		12.4580767	,
		41.9018257	,
		12.4580685	,
		41.9018093	,
		12.4580468	,
		41.9018151	,
		12.4580053	,
		41.9017303	,
		12.4580262	,
		41.9017246	,
		12.4580039	,
		41.9016865	,
		12.4579807	,
		41.9016587	,
		12.4579548	,
		41.9016236	,
		12.4579235	,
		41.9015922	,
		12.4578895	,
		41.90156	,
		12.4578589	,
		41.9015324	,
		12.4578266	,
		41.9015033	,
		12.4577879	,
		41.901481	,
		12.4577428	,
		41.9014553	,
		12.4577016	,
		41.9014358	,
		12.4576576	,
		41.9014145	,
		12.4576146	,
		41.9013968	,
		12.4575662	,
		41.9013819	,
		12.4575194	,
		41.9013706	,
		12.457474	,
		41.9013609	,
		12.4574169	,
		41.901353	,
		12.4573572	,
		41.9013483	,
		12.4573568	,
		41.9013676	,
		12.457203	,
		41.9013658	,
		12.4572034	,
		41.9013465	,
		12.4571661	,
		41.9013483	,
		12.4571126	,
		41.9013544	,
		12.4570638	,
		41.9013639	,
		12.4570128	,
		41.9013752	,
		12.4569672	,
		41.9013883	,
		12.4569154	,
		41.9014052	,
		12.4568742	,
		41.9014229	,
		12.4568311	,
		41.901446	,
		12.45679	,
		41.9014689	,
		12.4567703	,
		41.9014806	,
		12.4567493	,
		41.9014914	,
		12.4567113	,
		41.9015163	,
		12.4566757	,
		41.9015477	,
		12.4566449	,
		41.9015774	,
		12.4566151	,
		41.9016085	,
		12.4565822	,
		41.9016414	,
		12.4565488	,
		41.9016838	,
		12.4565666	,
		41.9016925	,
		12.4565386	,
		41.9017317	,
		12.4565045	,
		41.9017796	,
		12.4564894	,
		41.9017738	,
		12.4564723	,
		41.9017965	,
		12.4564495	,
		41.9018382	,
		12.4564245	,
		41.901891	,
		12.456403	,
		41.9019445	,
		12.4563851	,
		41.9019988	,
		12.4563708	,
		41.9020537	,
		12.4563601	,
		41.9021091	,
		12.4563531	,
		41.9021648	,
		12.4563499	,
		41.9022125	,
		12.4563501	,
		41.9022765	,
		12.4563541	,
		41.9023324	,
		12.4563618	,
		41.902388	,
		12.4563732	,
		41.9024433	,
		12.4563882	,
		41.902498	,
		12.4564068	,
		41.9025522	,
		12.456429	,
		41.9026056	,
		12.4564546	,
		41.9026582	,
		12.4564679	,
		41.9026756	,
		12.456492	,
		41.9026686	,
		12.4565214	,
		41.902714	,
		12.4565491	,
		41.9027567	,
		12.4565357	,
		41.9027607	,
		12.4565669	,
		41.9028017	,
		12.4565898	,
		41.9028378	,
		12.4566114	,
		41.9028639	,
		12.4566448	,
		41.9028928	,
		12.4566791	,
		41.9029235	,
		12.4566929	,
		41.9029332	,
		12.4567126	,
		41.9029476	,
		12.4567467	,
		41.902972	,
		12.4567779	,
		41.9029927	,
		12.4568251	,
		41.9030163	,
		12.4568687	,
		41.9030376	,
		12.4569141	,
		41.9030531	,
		12.4569626	,
		41.9030693	,
		12.4570082	,
		41.9030832	,
		12.4570499	,
		41.9030927	,
		12.4570971	,
		41.9031016	,
		12.4571395	,
		41.9031082	,
		12.4571401	,
		41.9030863	,
		12.4573038	,
		41.9030889	,
		12.4573032	,
		41.9031108	,
		12.457361	,
		41.9031067	,
		12.4574156	,
		41.9030982	,
		12.4574615	,
		41.9030906	,
		12.4575076	,
		41.9030806	,
		12.4575596	,
		41.9030653	,
		12.4576038	,
		41.9030515	,
		12.4576475	,
		41.9030359	,
		12.4576937	,
		41.9030155	,
		12.4577326	,
		41.9029925	,
		12.4577719	,
		41.9029687	,
		12.4578085	,
		41.9029448	,
		12.4578459	,
		41.9029183	,
		12.4578782	,
		41.9028911	,
		12.4579039	,
		41.9028622	,
		12.4579317	,
		41.902828	,
		12.4579542	,
		41.9027928	,
		12.4579301	,
		41.9027849	,
		12.4579784	,
		41.9027027	,
		12.4579996	,
		41.9027095	,
		12.4580094	,
		41.9026929	,
		12.458063	,
		41.9027103	};
	
	private double[][] inners3 = new double[][] {
	{	12.4572392	,
		41.9017313	,
		12.457239	,
		41.9017361	,
		12.4572494	,
		41.9017362	,
		12.4572493	,
		41.9017404	,
		12.4572876	,
		41.9017409	,
		12.4572877	,
		41.9017358	,
		12.4572993	,
		41.9017359	,
		12.4572994	,
		41.9017315	,
		12.4573068	,
		41.9017304	,
		12.4573126	,
		41.9017268	,
		12.457318	,
		41.9017225	,
		12.4573202	,
		41.9017173	,
		12.4573256	,
		41.9017174	,
		12.4573258	,
		41.9017093	,
		12.4573307	,
		41.9017094	,
		12.4573316	,
		41.9016851	,
		12.4573255	,
		41.901685	,
		12.4573256	,
		41.9016778	,
		12.4573257	,
		41.9016746	,
		12.4573198	,
		41.9016745	,
		12.4573194	,
		41.9016691	,
		12.4573152	,
		41.9016653	,
		12.4573051	,
		41.9016595	,
		12.4573007	,
		41.901659	,
		12.457301	,
		41.901654	,
		12.4572898	,
		41.9016537	,
		12.4572901	,
		41.9016486	,
		12.4572534	,
		41.9016476	,
		12.4572532	,
		41.9016533	,
		12.4572407	,
		41.9016529	,
		12.4572405	,
		41.9016579	,
		12.4572351	,
		41.901659	,
		12.4572294	,
		41.9016624	,
		12.4572236	,
		41.9016677	,
		12.4572208	,
		41.9016726	,
		12.4572158	,
		41.9016725	,
		12.4572154	,
		41.9016806	,
		12.45721	,
		41.9016804	,
		12.4572087	,
		41.9017075	,
		12.4572152	,
		41.9017077	,
		12.4572149	,
		41.9017156	,
		12.4572194	,
		41.9017157	,
		12.4572208	,
		41.9017193	,
		12.4572236	,
		41.9017229	,
		12.4572267	,
		41.9017259	,
		12.4572306	,
		41.9017284	,
		12.4572335	,
		41.9017303	},


			
			{	12.4571891	,
				41.9021831	,
				12.4573161	,
				41.9021862	,
				12.4573116	,
				41.9022871	,
				12.4571846	,
				41.902284	},

	{	12.4571978	,
		41.9028066	,
		12.4571977	,
		41.9028114	,
		12.457208	,
		41.9028115	,
		12.4572079	,
		41.9028156	,
		12.4572462	,
		41.9028162	,
		12.4572463	,
		41.9028111	,
		12.4572579	,
		41.9028112	,
		12.457258	,
		41.9028067	,
		12.4572654	,
		41.9028057	,
		12.4572713	,
		41.9028021	,
		12.4572766	,
		41.9027978	,
		12.4572788	,
		41.9027926	,
		12.4572842	,
		41.9027927	,
		12.4572844	,
		41.9027846	,
		12.4572893	,
		41.9027847	,
		12.4572902	,
		41.9027604	,
		12.4572841	,
		41.9027603	,
		12.4572842	,
		41.9027531	,
		12.4572843	,
		41.9027499	,
		12.4572784	,
		41.9027498	,
		12.4572781	,
		41.9027444	,
		12.4572738	,
		41.9027406	,
		12.4572638	,
		41.9027348	,
		12.4572593	,
		41.9027343	,
		12.4572596	,
		41.9027293	,
		12.4572484	,
		41.902729	,
		12.4572487	,
		41.9027239	,
		12.4572121	,
		41.9027229	,
		12.4572118	,
		41.9027286	,
		12.4571994	,
		41.9027282	,
		12.4571991	,
		41.9027332	,
		12.4571937	,
		41.9027342	,
		12.457188	,
		41.9027377	,
		12.4571823	,
		41.902743	,
		12.4571794	,
		41.9027479	,
		12.4571744	,
		41.9027477	,
		12.457174	,
		41.9027559	,
		12.4571686	,
		41.9027557	,
		12.4571673	,
		41.9027828	,
		12.4571738	,
		41.902783	,
		12.4571735	,
		41.9027909	,
		12.457178	,
		41.902791	,
		12.4571794	,
		41.9027946	,
		12.4571823	,
		41.9027982	,
		12.4571853	,
		41.9028012	,
		12.4571892	,
		41.9028037	,
		12.4571921	,
		41.9028055	},

	{	12.4565222	,
		41.902614	,
		12.456498	,
		41.9025605	,
		12.4564783	,
		41.902506	,
		12.4564631	,
		41.9024507	,
		12.4564524	,
		41.9023949	,
		12.4564463	,
		41.9023387	,
		12.4564447	,
		41.9022823	,
		12.4564325	,
		41.9022741	,
		12.4564341	,
		41.9023343	,
		12.456441	,
		41.9023942	,
		12.4564529	,
		41.9024537	,
		12.4564697	,
		41.9025125	,
		12.4564915	,
		41.9025704	,
		12.4565178	,
		41.9026269	},

	{	12.4564447	,
		41.9022823	,
		12.4569287	,
		41.902292	,
		12.4569338	,
		41.9023072	,
		12.4569428	,
		41.9023266	,
		12.4569516	,
		41.9023411	,
		12.4569648	,
		41.9023587	,
		12.4569761	,
		41.9023712	,
		12.4565222	,
		41.902614	,
		12.4565178	,
		41.9026269	,
		12.4569898	,
		41.9023721	,
		12.4569846	,
		41.9023673	,
		12.456973	,
		41.902355	,
		12.4569616	,
		41.9023402	,
		12.4569528	,
		41.902326	,
		12.4569437	,
		41.9023057	,
		12.4569381	,
		41.9022859	,
		12.4564325	,
		41.9022741	},

	{	12.4564485	,
		41.902147	,
		12.4569325	,
		41.9021554	,
		12.4569386	,
		41.9021405	,
		12.4569489	,
		41.9021214	,
		12.4569586	,
		41.9021073	,
		12.456973	,
		41.9020901	,
		12.4569852	,
		41.9020781	,
		12.4565488	,
		41.9018186	,
		12.456545	,
		41.9018052	,
		12.4569989	,
		41.9020777	,
		12.4569934	,
		41.9020823	,
		12.456981	,
		41.9020942	,
		12.4569686	,
		41.9021085	,
		12.4569589	,
		41.9021224	,
		12.4569483	,
		41.9021423	,
		12.4569414	,
		41.9021619	,
		12.4564356	,
		41.9021548	},

	{	12.4565488	,
		41.9018186	,
		12.4565206	,
		41.9018711	,
		12.4564972	,
		41.9019247	,
		12.4564782	,
		41.9019794	,
		12.4564638	,
		41.9020348	,
		12.4564538	,
		41.9020907	,
		12.4564485	,
		41.902147	,
		12.4564356	,
		41.9021548	,
		12.4564413	,
		41.9020946	,
		12.4564523	,
		41.902035	,
		12.4564682	,
		41.9019761	,
		12.456489	,
		41.901918	,
		12.4565147	,
		41.9018609	,
		12.456545	,
		41.9018052	},

	{	12.4565829	,
		41.9027437	,
		12.4565987	,
		41.9027465	,
		12.4570415	,
		41.9024288	,
		12.4570577	,
		41.902438	,
		12.4570802	,
		41.9024489	,
		12.4571005	,
		41.902457	,
		12.4571235	,
		41.9024646	,
		12.4571509	,
		41.9024716	,
		12.4571298	,
		41.9030496	,
		12.457141	,
		41.9030597	,
		12.4571618	,
		41.902466	,
		12.4571545	,
		41.9024645	,
		12.4571271	,
		41.9024574	,
		12.4571081	,
		41.902451	,
		12.4570881	,
		41.9024429	,
		12.4570649	,
		41.9024314	,
		12.4570419	,
		41.9024173	},

	{	12.4565987	,
		41.9027465	,
		12.4565829	,
		41.9027437	,
		12.4566127	,
		41.9027879	,
		12.4566477	,
		41.9028299	,
		12.4566878	,
		41.9028694	,
		12.4567325	,
		41.902906	,
		12.4567816	,
		41.9029394	,
		12.4568345	,
		41.9029694	,
		12.4568908	,
		41.9029957	,
		12.4569502	,
		41.903018	,
		12.457012	,
		41.9030362	,
		12.4570758	,
		41.9030501	,
		12.457141	,
		41.9030597	,
		12.4571298	,
		41.9030496	,
		12.4570679	,
		41.9030398	,
		12.4570073	,
		41.903026	,
		12.4569487	,
		41.9030082	,
		12.4568924	,
		41.9029866	,
		12.4568389	,
		41.9029614	,
		12.4567887	,
		41.9029327	,
		12.4567421	,
		41.9029008	,
		12.4566994	,
		41.902866	,
		12.4566611	,
		41.9028284	,
		12.4566275	,
		41.9027885	},

	{	12.4566242	,
		41.9016958	,
		12.4566403	,
		41.9016935	,
		12.4570608	,
		41.9020276	,
		12.4570777	,
		41.902019	,
		12.4571008	,
		41.902009	,
		12.4571217	,
		41.9020016	,
		12.4571451	,
		41.9019949	,
		12.4571731	,
		41.901989	,
		12.4571913	,
		41.9014109	,
		12.4572032	,
		41.9014012	,
		12.4571836	,
		41.9019949	,
		12.4571761	,
		41.9019962	,
		12.4571482	,
		41.9020022	,
		12.4571288	,
		41.9020079	,
		12.4571083	,
		41.9020152	,
		12.4570844	,
		41.9020258	,
		12.4570604	,
		41.9020391	},

	{	12.4566403	,
		41.9016935	,
		12.4566242	,
		41.9016958	,
		12.456657	,
		41.9016527	,
		12.4566949	,
		41.9016121	,
		12.4567376	,
		41.9015742	,
		12.4567848	,
		41.9015393	,
		12.456836	,
		41.9015078	,
		12.4568909	,
		41.9014799	,
		12.456949	,
		41.9014558	,
		12.4570098	,
		41.9014357	,
		12.4570727	,
		41.9014198	,
		12.4571374	,
		41.9014083	,
		12.4572032	,
		41.9014012	,
		12.4571913	,
		41.9014109	,
		12.4571288	,
		41.9014183	,
		12.4570674	,
		41.9014299	,
		12.4570076	,
		41.9014454	,
		12.45695	,
		41.9014648	,
		12.4568948	,
		41.901488	,
		12.4568427	,
		41.9015148	,
		12.4567939	,
		41.9015449	,
		12.456749	,
		41.901578	,
		12.4567082	,
		41.9016141	,
		12.4566719	,
		41.9016527	},

	{	12.4578836	,
		41.902765	,
		12.4578675	,
		41.9027673	,
		12.4574447	,
		41.9024349	,
		12.4574279	,
		41.9024436	,
		12.4574048	,
		41.9024536	,
		12.457384	,
		41.9024611	,
		12.4573606	,
		41.9024679	,
		12.4573327	,
		41.9024739	,
		12.4573184	,
		41.903052	,
		12.4573066	,
		41.9030618	,
		12.4573222	,
		41.902468	,
		12.4573296	,
		41.9024668	,
		12.4573575	,
		41.9024606	,
		12.4573769	,
		41.9024549	,
		12.4573973	,
		41.9024474	,
		12.4574212	,
		41.9024367	,
		12.457445	,
		41.9024234	},

	{	12.4578675	,
		41.9027673	,
		12.4578836	,
		41.902765	,
		12.4578511	,
		41.9028082	,
		12.4578135	,
		41.902849	,
		12.457771	,
		41.9028871	,
		12.4577241	,
		41.9029221	,
		12.4576731	,
		41.9029538	,
		12.4576184	,
		41.902982	,
		12.4575605	,
		41.9030063	,
		12.4574998	,
		41.9030266	,
		12.457437	,
		41.9030427	,
		12.4573724	,
		41.9030544	,
		12.4573066	,
		41.9030618	,
		12.4573184	,
		41.903052	,
		12.4573809	,
		41.9030444	,
		12.4574422	,
		41.9030326	,
		12.4575019	,
		41.9030169	,
		12.4575594	,
		41.9029972	,
		12.4576144	,
		41.9029738	,
		12.4576664	,
		41.9029469	,
		12.4577149	,
		41.9029166	,
		12.4577596	,
		41.9028832	,
		12.4578002	,
		41.902847	,
		12.4578362	,
		41.9028083	},

	{	12.4580563	,
		41.9023132	,
		12.4575722	,
		41.9023066	,
		12.4575662	,
		41.9023215	,
		12.457556	,
		41.9023406	,
		12.4575464	,
		41.9023548	,
		12.4575321	,
		41.902372	,
		12.45752	,
		41.9023841	,
		12.4579582	,
		41.902642	,
		12.457962	,
		41.9026553	,
		12.4575063	,
		41.9023845	,
		12.4575117	,
		41.9023799	,
		12.4575241	,
		41.902368	,
		12.4575364	,
		41.9023536	,
		12.457546	,
		41.9023397	,
		12.4575564	,
		41.9023197	,
		12.4575632	,
		41.9023002	,
		12.458069	,
		41.9023053	},

	{	12.4579582	,
		41.902642	,
		12.457986	,
		41.9025893	,
		12.458009	,
		41.9025356	,
		12.4580276	,
		41.9024809	,
		12.4580417	,
		41.9024255	,
		12.4580513	,
		41.9023695	,
		12.4580563	,
		41.9023132	,
		12.458069	,
		41.9023053	,
		12.4580637	,
		41.9023655	,
		12.4580532	,
		41.9024251	,
		12.4580377	,
		41.9024842	,
		12.4580172	,
		41.9025423	,
		12.457992	,
		41.9025995	,
		12.457962	,
		41.9026553	},

	{	12.458059	,
		41.9021779	,
		12.457575	,
		41.9021699	,
		12.4575698	,
		41.9021549	,
		12.4575606	,
		41.9021355	,
		12.4575518	,
		41.902121	,
		12.4575384	,
		41.9021034	,
		12.457527	,
		41.9020909	,
		12.4579793	,
		41.9018465	,
		12.4579836	,
		41.9018335	,
		12.4575134	,
		41.9020901	,
		12.4575186	,
		41.9020949	,
		12.4575303	,
		41.9021072	,
		12.4575418	,
		41.9021219	,
		12.4575506	,
		41.9021361	,
		12.4575599	,
		41.9021563	,
		12.4575657	,
		41.9021761	,
		12.4580713	,
		41.902186	},

	{	12.4579793	,
		41.9018465	,
		12.4580038	,
		41.9018999	,
		12.4580239	,
		41.9019543	,
		12.4580395	,
		41.9020095	,
		12.4580506	,
		41.9020653	,
		12.4580571	,
		41.9021215	,
		12.458059	,
		41.9021779	,
		12.4580713	,
		41.902186	,
		12.4580693	,
		41.9021258	,
		12.458062	,
		41.9020659	,
		12.4580497	,
		41.9020065	,
		12.4580325	,
		41.9019478	,
		12.4580103	,
		41.9018899	,
		12.4579836	,
		41.9018335	},

	{	12.4579178	,
		41.901717	,
		12.4579019	,
		41.9017142	,
		12.4574613	,
		41.9020336	,
		12.457445	,
		41.9020245	,
		12.4574225	,
		41.9020137	,
		12.4574021	,
		41.9020056	,
		12.4573791	,
		41.9019981	,
		12.4573515	,
		41.9019913	,
		12.4573687	,
		41.9014132	,
		12.4573575	,
		41.9014031	,
		12.4573407	,
		41.9019968	,
		12.457348	,
		41.9019983	,
		12.4573755	,
		41.9020053	,
		12.4573946	,
		41.9020116	,
		12.4574146	,
		41.9020197	,
		12.4574379	,
		41.9020311	,
		12.457461	,
		41.9020451	},

	{	12.4579019	,
		41.9017142	,
		12.4579178	,
		41.901717	,
		12.4578877	,
		41.9016729	,
		12.4578523	,
		41.901631	,
		12.4578119	,
		41.9015917	,
		12.457767	,
		41.9015552	,
		12.4577177	,
		41.901522	,
		12.4576646	,
		41.9014922	,
		12.4576081	,
		41.9014662	,
		12.4575486	,
		41.9014441	,
		12.4574866	,
		41.9014261	,
		12.4574228	,
		41.9014124	,
		12.4573575	,
		41.9014031	,
		12.4573687	,
		41.9014132	,
		12.4574307	,
		41.9014227	,
		12.4574914	,
		41.9014363	,
		12.4575501	,
		41.9014539	,
		12.4576065	,
		41.9014752	,
		12.4576602	,
		41.9015003	,
		12.4577106	,
		41.9015287	,
		12.4577575	,
		41.9015605	,
		12.4578004	,
		41.9015951	,
		12.4578389	,
		41.9016325	,
		12.4578728	,
		41.9016723	}};


		private double[] outer4 = new double[] {
	74.5450059	,
	65.8606142	,
	74.5449302	,
	65.8605419	,
	74.5449806	,
	65.8604594	,
	74.5451724	,
	65.8604435	,
	74.5452451	,
	65.8603907	,
	74.545237	,
	65.8603081	,
	74.5452451	,
	65.8602553	,
	74.5453743	,
	65.860285	,
	74.5455439	,
	65.8603378	,
	74.5457457	,
	65.860427	,
	74.5457942	,
	65.8605029	,
	74.5457134	,
	65.8606185	,
	74.5455196	,
	65.8606747	,
	74.5452612	,
	65.8606714	,
	74.545124	,
	65.8606648
};

private double[] outer5 = new double[] {
37.6098024	,
55.7514771	,
37.6099155	,
55.7514581	,
37.6099694	,
55.7515595	,
37.60996	,
55.7515611	,
37.6099483	,
55.7515631	,
37.6099366	,
55.751565	,
37.6099248	,
55.751567	,
37.609913	,
55.751569	,
37.6099013	,
55.751571	,
37.6098895	,
55.7515729	,
37.6098778	,
55.7515749	,
37.609866	,
55.7515769	,
37.6098542	,
55.7515789	,
37.6098425	,
55.7515809	,
37.6098308	,
55.7515828	,
37.6099795	,
55.7518581	,
37.6100751	,
55.7520324	,
37.6095519	,
55.7521225	,
37.6095551	,
55.7521284	,
37.6095584	,
55.7521344	,
37.6095616	,
55.7521404	,
37.6095648	,
55.7521463	,
37.6095681	,
55.7521523	,
37.6095713	,
55.7521582	,
37.6095746	,
55.7521642	,
37.6095778	,
55.7521702	,
37.6095811	,
55.7521761	,
37.6095843	,
55.7521821	,
37.6095875	,
55.7521881	,
37.6095909	,
55.7521942	,
37.6093606	,
55.752234	,
37.6092271	,
55.7519902	,
37.6091943	,
55.7519302	,
37.6091486	,
55.7518468	,
37.6093902	,
55.7518052	,
37.6094613	,
55.7519356	,
37.6096626	,
55.7519008	,
37.6098789	,
55.7518634	,
37.609757	,
55.7516399	,
37.6097518	,
55.7516408	,
37.609745	,
55.751642	,
37.609738	,
55.7516432	,
37.6097312	,
55.7516444	,
37.6097244	,
55.7516456	,
37.6097174	,
55.7516468	,
37.6097138	,
55.7516474	,
37.6096381	,
55.7515048	};

private double[][] inners5 = new double[][] {
{	37.609914	,
55.7519601	,
37.6097786	,
55.7519848	,
37.609824	,
55.7520636	,
37.6099594	,
55.7520389	},

{	37.6093048	,
55.7520156	,
37.6093458	,
55.7520911	,
37.6094744	,
55.752069	,
37.6094334	,
55.7519935	},

{	37.6092403	,
55.7518795	,
37.6092773	,
55.7519504	,
37.6094037	,
55.7519295	,
37.6093666	,
55.7518586	}};


	private double[] outer6 = new double[] {
30.3101262	,
59.9362745	,
30.3103735	,
59.936109	,
30.3105238	,
59.9360085	,
30.3095968	,
59.9356513	,
30.3091803	,
59.9359184	};

private double[][] inners6 = new double[][] {
{	30.3094597	,
59.9358467	,
30.3096163	,
59.9359086	,
30.3097849	,
59.9358018	,
30.3096284	,
59.9357398	},

{	30.3097822	,
59.9359796	,
30.3100405	,
59.9360828	,
30.3101361	,
59.9360228	,
30.3102167	,
59.9359722	,
30.3099583	,
59.9358689	}};

	private double[] outer7 = new double[] {
30.3024851	,
59.9329832	,
30.3026344	,
59.9330267	,
30.3029173	,
59.9331084	,
30.3035687	,
59.9332979	,
30.3039036	,
59.9330157	,
30.3041125	,
59.9328364	,
30.3038078	,
59.9327471	,
30.3035729	,
59.9326783	,
30.303426	,
59.9326353	,
30.3030229	,
59.9325172	,
30.3029512	,
59.9325793	,
30.3028743	,
59.9326459	,
30.3028052	,
59.9327059	};

private double[][] inners7 = new double[][] {
{	30.3028763	,
59.9328136	,
30.3031604	,
59.9328947	,
30.3032348	,
59.9328292	,
30.3033039	,
59.932769	,
30.303019	,
59.9326888	,
30.3029523	,
59.9327473	},

{	30.3026344	,
59.9330267	,
30.3029173	,
59.9331084	,
30.3030496	,
59.9329933	,
30.3027667	,
59.9329116	},

{	30.3032416	,
59.9330957	,
30.3034894	,
59.933166	,
30.3035868	,
59.9330797	,
30.3033386	,
59.9330087},	

{	30.3035882	,
59.9327901	,
30.3034691	,
59.932894	,
30.3035965	,
59.9329299	,
30.30372	,
59.9329642	,
30.3038381	,
59.9328609	,
30.3037175	,
59.9328269	}};

	private double[] outer8 = new double[] {
12.4696411	,
41.9014154	,
12.4697537	,
41.901429	,
12.4698561	,
41.9014426	,
12.4700295	,
41.9014652	,
12.4700458	,
41.9013716	,
12.47006	,
41.901238	,
12.4700742	,
41.9011437	,
12.4700926	,
41.90106	,
12.4701297	,
41.9009012	,
12.4701502	,
41.9008168	,
12.4701472	,
41.9007262	,
12.4699983	,
41.9007268	,
12.4699943	,
41.9007504	,
12.4699123	,
41.9007443	,
12.4699139	,
41.9007153	,
12.4698725	,
41.9007166	,
12.4698766	,
41.9008452	,
12.4697906	,
41.9008467	,
12.4697313	,
41.9008478	,
12.4696162	,
41.9008498	,
12.4696155	,
41.9008287	,
12.4695862	,
41.9008293	,
12.4695857	,
41.9008159	,
12.4695521	,
41.9008165	,
12.4695525	,
41.9008322	,
12.4695122	,
41.900833	,
12.4695116	,
41.9008166	,
12.4694696	,
41.9008174	,
12.4694701	,
41.9008336	,
12.4694309	,
41.9008342	,
12.4694303	,
41.9008174	,
12.4693896	,
41.9008182	,
12.4693901	,
41.9008348	,
12.469351	,
41.9008354	,
12.4693505	,
41.9008182	,
12.4693076	,
41.900819	,
12.4693083	,
41.9008395	,
12.469273	,
41.9008401	,
12.4692792	,
41.9010127	,
12.4692876	,
41.901187	,
12.4695012	,
41.9011783	,
12.4695022	,
41.9012071	,
12.4694728	,
41.9012056	,
12.4694038	,
41.9012056	,
12.4693977	,
41.9012259	,
12.4693003	,
41.9012161	,
12.4692943	,
41.9012425	,
12.4692831	,
41.901244	,
12.4692486	,
41.9013761	};

private double[][] inners8 = new double[][] {
{ 	12.4695914	,
41.9013165	,
12.4695579	,
41.9013173	,
12.4695579	,
41.9012765	,
12.4695899	,
41.9012764	},

{ 	12.4698794	,
41.9009051	,
12.4700381	,
41.900911	,
12.4699734	,
41.9011982	,
12.4697449	,
41.9012001	,
12.4697337	,
41.9009081	},

{ 	12.4694514	,
41.9008736	,
12.4695853	,
41.9008696	,
12.4695853	,
41.9009663	,
12.4694545	,
41.9009678	},

{ 	12.4695488	,
41.9010842	,
12.4694149	,
41.9010891	,
12.4694125	,
41.9010168	,
12.4695448	,
41.9010115	},

{ 	12.4694929	,
41.9013026	,
12.4694912	,
41.9013238	,
12.4695211	,
41.9013251	,
12.4695228	,
41.901304	}};

	private double[] outer9 = new double[] {
30.2925273	,
59.9334392	,
30.2930504	,
59.9329876	,
30.2929907	,
59.9329694	,
30.2928487	,
59.9329262	,
30.2928157	,
59.9329161	,
30.2926434	,
59.9328636	,
30.2926206	,
59.9328567	,
30.2921497	,
59.9333325	,
30.2922579	,
59.9333649	,
30.2924221	,
59.9334095	};

private double[][] inners9 = new double[][] {
{ 	30.2922579	,
59.9333649	,
30.2924221	,
59.9334095	,
30.2926722	,
59.9331962	,
30.2924702	,
59.9331407	},

{	30.2925365	,
59.9330669	,
30.2926725	,
59.9331054	,
30.2927712	,
59.9330201	,
30.2927139	,
59.9330044	,
30.2926297	,
59.9329824	}};

	private double[] outer10 = new double[] {
	12.469128,41.9044899,
	12.4695001, 41.9046085,
	12.4694792,41.9046447,
	12.4706075,41.905018,
	12.4706321,41.9049851,
	12.4709961,41.9051041,
	12.4717515,41.9038215,
	12.4716113,41.9037719,
	12.4715588,41.9037914,
	12.4713734,41.9037338,
	12.4713945,41.903698,
	12.4702414,41.9033212,
	12.4702227,41.9033503,
	12.4700186,41.9032778,
	12.470016,41.9032465,
	12.4698852,41.9032041	 };

private double[][] inners10 = new double[][] {
	{ 12.4694197,41.9043986,
		  12.4695785,41.9044508,
		  12.4696569,41.904324,
		  12.4694962,41.9042708 }, 
		{ 12.4695789,41.9041375,
		  12.4697235,41.9041856,
		  12.469799,41.9040602,
		  12.4696544,41.904012 }, 
		{ 12.4697626,41.9038352,
		  12.4699087,41.9038844,
		  12.4699876,41.9037546,
		  12.4698415,41.9037054 }, 
		{ 12.4699005,41.9035786,
		  12.4700608,41.9036326,
		  12.4701482,41.9034912,
		  12.4699868,41.9034368 }, 
		{ 12.4702065,41.9039766,
		  12.470316,41.9040086,
	      12.4703658,41.9039559,
		  12.4704419,41.9039266,
		  12.4705101,41.9039305,
		  12.4706015,41.9039576,
		  12.4706492,41.9039969,
		  12.4706728,41.9040477,
		  12.4706518,41.9041238,
		  12.4707549,41.9041535,
		  12.470987,41.9037627,
		  12.4704377,41.9035848 },
		{ 12.4698803,41.9045361,
		  12.4700582,41.9045949,
		  12.470103,41.9045198,
		  12.4700797,41.9045121,
		  12.470214,41.9042868,
		  12.4702373,41.9042945,
		  12.4702789,41.9042248,
		  12.4701009,41.9041661 }, 
		{ 12.4702467,41.9046582,
		  12.4704169,41.9047156,
		  12.4706415,41.9043464,
		  12.4704713,41.904289,
		  12.4704286,41.9043592,
		  12.4704578,41.904369,
		  12.4703206,41.9045945,
		  12.4702914,41.9045847 }, 
		{ 12.4707199,41.9048171,
		  12.4708647,41.9048652,
		  12.4709322,41.9047525,
		  12.4707874,41.9047045 }, 
		{ 12.4708705,41.9045663,
		  12.4710168,41.9046148,
		  12.4710882,41.9044953,
		  12.4709419,41.9044469 }, 
		{ 12.4710619,41.9042574,
		  12.4712059,41.9043046,
		  12.4712805,41.904182,
		  12.4711361,41.9041338 }, 
		{ 12.4712802,41.9038663,
		  12.4714257,41.9039162,
		  12.4713459,41.9040474,
		  12.4712002,41.9039995	}};
	private double[] outer11 = new double[] {
	12.4723896	,
	41.9046053	,
	12.4724666	,
	41.9045997	,
	12.4724734	,
	41.9046519	,
	12.4725328	,
	41.9046476	,
	12.4725396	,
	41.9046993	,
	12.4725636	,
	41.9046976	,
	12.4725683	,
	41.9047338	,
	12.4725054	,
	41.9047384	,
	12.47248	,
	41.9047698	,
	12.4724318	,
	41.9047482	,
	12.4724805	,
	41.9046879	,
	12.4724292	,
	41.904665	,
	12.4723979	,
	41.9047038	,
	12.4723334	,
	41.9046749	,
	12.4723089	,
	41.9047052	,
	12.4722798	,
	41.9047413	,
	12.4725738	,
	41.9048728	,
	12.4726692	,
	41.9048322	,
	12.4726195	,
	41.9044526	,
	12.4724295	,
	41.9044664	,
	12.4723097	,
	41.9044751	
};	
private double[][] inners11 = new double[][] {
	{ 	12.4724964	,
		41.9045617	,
		12.4725431	,
		41.9045583	,
		12.4725489	,
		41.9046022	,
		12.4725021	,
		41.9046056		}};

	private double[] outer12 = new double[] {
	12.4721715	,
	41.9054402	,
	12.4721514	,
	41.9054416	,
	12.4721392	,
	41.9054423	,
	12.4721111	,
	41.9051917	,
	12.4721357	,
	41.9051901	,
	12.4721341	,
	41.9051757	,
	12.4722279	,
	41.9051698	,
	12.4722292	,
	41.9051817	,
	12.4727301	,
	41.9051506	,
	12.4727578	,
	41.9053976	,
	12.4727458	,
	41.9053983	,
	12.4727308	,
	41.9053993	,
	12.4727291	,
	41.9053852	,
	12.4726312	,
	41.9053916	,
	12.4726299	,
	41.9053807	,
	12.4725705	,
	41.9053846	,
	12.4723283	,
	41.9053994	,
	12.4722628	,
	41.9054037	,
	12.4722645	,
	41.9054183	,
	12.4721697	,
	41.9054245
};

private double[][] inners12 = new double[][] {
	{ 	12.4725172	,
		41.9053324	,
		12.4725773	,
		41.9053291	,
		12.4725699	,
		41.9052554	,
		12.4725098	,
		41.9052587	 }, 
		{ 	12.4722898	,
			41.9053482	,
			12.4723348	,
			41.9053453	,
			12.4723264	,
			41.9052725	,
			12.4722815	,
			41.9052754		}};

	private double[] outer13 = new double[] {
		39.0003136	,
		44.1655643	,
		38.9986451	,
		44.1662979	,
		38.9986125	,
		44.1663562	,
		38.9985854	,
		44.1664224	,
		38.9985746	,
		44.1665119	,
		38.9989597	,
		44.1674769	,
		38.9991604	,
		44.1677142	,
		38.999836	,
		44.1681708	,
		39.0003763	,
		44.1682868	,
		39.0003629	,
		44.1683163	,
		39.0003368	,
		44.1683758	,
		39.0003677	,
		44.1683717	,
		39.0003828	,
		44.1683855	,
		39.0004166	,
		44.168381	,
		39.0004444	,
		44.1684096	,
		39.0004079	,
		44.1684186	,
		39.0003861	,
		44.1684676	,
		39.0003863	,
		44.1685156	,
		39.0005417	,
		44.168663	,
		39.0006181	,
		44.1687407	,
		39.0008385	,
		44.1691895	,
		39.0009256	,
		44.1692597	,
		39.0010216	,
		44.1692966	,
		39.0011193	,
		44.1693145	,
		39.0012295	,
		44.1693119	,
		39.001338	,
		44.1692788	,
		39.00145	,
		44.169238	,
		39.0014162	,
		44.1691908	,
		39.002312	,
		44.1687879	,
		39.0026889	,
		44.168589	,
		39.002728	,
		44.1686298	,
		39.0027822	,
		44.1686013	,
		39.0029393	,
		44.1685247	,
		39.0028815	,
		44.1684687	,
		39.0031062	,
		44.1683494	,
		39.0031735	,
		44.1684147	,
		39.0032381	,
		44.1683723	,
		39.0032506	,
		44.1683378	,
		39.0032417	,
		44.168283	,
		39.0031404	,
		44.1679464	,
		39.0030497	,
		44.1677144	,
		39.002991	,
		44.1675716	,
		39.0028773	,
		44.167351	,
		39.002664	,
		44.1670335	,
		39.0023797	,
		44.1667332	,
		39.0021315	,
		44.1664911	,
		39.0020064	,
		44.1663892	,
		39.00183	,
		44.1662787	,
		39.0016338	,
		44.1661924	,
		39.0014074	,
		44.1661169	,
		39.0009946	,
		44.1659933	,
		39.0007982	,
		44.1659335	,
		39.0006565	,
		44.165874	,
		39.0005171	,
		44.1657798	};

	private double[][] inners13 = new double[][] {
	{	39.0018994	,
		44.16763	,
		39.001923	,
		44.1676714	,
		39.001974	,
		44.1676484	,
		39.0019875	,
		44.1676544	,
		39.0020866	,
		44.1676316	,
		39.0021258	,
		44.1676163	,
		39.0021508	,
		44.1675948	,
		39.0021648	,
		44.1675775	,
		39.0021695	,
		44.167553	,
		39.0021635	,
		44.1675282	,
		39.0021431	,
		44.1675061	,
		39.0021157	,
		44.1674951	,
		39.0021157	,
		44.1674706	,
		39.0021055	,
		44.1674473	,
		39.0020884	,
		44.167429	,
		39.0020696	,
		44.1674143	,
		39.0020372	,
		44.1674057	,
		39.002009	,
		44.1674022	,
		39.0019714	,
		44.167409	,
		39.001933	,
		44.167426	,
		39.0019051	,
		44.1674561	,
		39.0018807	,
		44.1674929	,
		39.0018685	,
		44.167539	,
		39.0018684	,
		44.1675765	,
		39.0018705	,
		44.1675853	,
		39.0018762	,
		44.1675823	,
		39.0018826	,
		44.1675802	,
		39.0018894	,
		44.167579	,
		39.0018965	,
		44.1675788	,
		39.0019034	,
		44.1675796	,
		39.00191	,
		44.1675813	,
		39.001916	,
		44.1675839	,
		39.0019212	,
		44.1675874	,
		39.0019253	,
		44.1675914	,
		39.0019283	,
		44.167596	,
		39.00193	,
		44.1676009	,
		39.0019302	,
		44.167606	,
		39.0019292	,
		44.167611	,
		39.0019267	,
		44.1676157	,
		39.0019231	,
		44.16762	,
		39.0019183	,
		44.1676237	,
		39.0019126	,
		44.1676267	,
		39.0019062	,
		44.1676288	},
		
	{	39.0018676	,
		44.1676216	,
		39.0018728	,
		44.1676251	,
		39.0018788	,
		44.1676277	,
		39.0018854	,
		44.1676294	,
		39.0018923	,
		44.1676302	,
		39.0018994	,
		44.16763	,
		39.0019062	,
		44.1676288	,
		39.0019126	,
		44.1676267	,
		39.0019183	,
		44.1676237	,
		39.0019231	,
		44.16762	,
		39.0019267	,
		44.1676157	,
		39.0019292	,
		44.167611	,
		39.0019302	,
		44.167606	,
		39.00193	,
		44.1676009	,
		39.0019283	,
		44.167596	,
		39.0019253	,
		44.1675914	,
		39.0019212	,
		44.1675874	,
		39.001916	,
		44.1675839	,
		39.00191	,
		44.1675813	,
		39.0019034	,
		44.1675796	,
		39.0018965	,
		44.1675788	,
		39.0018894	,
		44.167579	,
		39.0018826	,
		44.1675802	,
		39.0018762	,
		44.1675823	,
		39.0018705	,
		44.1675853	,
		39.0018657	,
		44.167589	,
		39.0018621	,
		44.1675933	,
		39.0018597	,
		44.167598	,
		39.0018586	,
		44.167603	,
		39.0018588	,
		44.1676081	,
		39.0018605	,
		44.167613	,
		39.0018635	,
		44.1676176	}};

	private double[] outer14 = new double[] {
				20.4864517	,
				54.954402	,
				20.48632	,
				54.9543628	,
				20.4859931	,
				54.9541571	,
				20.4859338	,
				54.9540648	,
				20.4859668	,
				54.9539883	,
				20.4860926	,
				54.9539279	,
				20.4864815	,
				54.9537563	,
				20.487066	,
				54.9536704	,
				20.4872237	,
				54.9536805	,
				20.4875348	,
				54.9537537	,
				20.4877314	,
				54.9538057	,
				20.4884948	,
				54.9535841	,
				20.488638	,
				54.9536423	,
				20.4885747	,
				54.9537338	,
				20.4885433	,
				54.9537842	,
				20.4885651	,
				54.9538543	,
				20.4883583	,
				54.9541917	,
				20.4882016	,
				54.9544674	,
				20.487961	,
				54.9545241	,
				20.4878068	,
				54.9547681	,
				20.487736	,
				54.9549022	,
				20.4876483	,
				54.9549433	,
				20.4874474	,
				54.9549851	,
				20.4871124	,
				54.9550133	,
				20.4868509	,
				54.9550042	,
				20.4867119	,
				54.9549911	,
				20.4866285	,
				54.9549629	,
				20.4865853	,
				54.9549187	,
				20.486603	,
				54.9548595	,
				20.4865165	,
				54.9547712	,
				20.4864796	,
				54.9546924	,
				20.4865361	,
				54.9545855	,
				20.4865338	,
				54.95445	};
	
	private double[][] inners14 = new double[][] {{
				20.4878022	,
				54.9539285	,
				20.4879578	,
				54.9541195	,
				20.4880705	,
				54.9541472	,
				20.4882153	,
				54.9541072	,
				20.4883548	,
				54.9539778	,
				20.4883387	,
				54.9538946	,
				20.4882636	,
				54.9538238	,
				20.4881187	,
				54.9538299	,
				20.487931	,
				54.9538576	,
				20.4878559	,
				54.9538885	}};

	
	private double[] outer15 = new double[] {1,1, 1,7, 16,7, 16,1};
	
	private double[][] inners15 = new double[][] {
			{15,4, 13,4, 13,5, 13,6, 15,6},
			{12,2, 12,3, 14,3, 14,2},
			{10,6, 2,6, 2,2, 4,2, 4,4, 3,4, 3,5, 9,5, 9,4, 8,4, 8,2, 10,2},
			{6,4, 6,3, 6,2, 8,2, 8,4}, 
			{11,6, 11,4, 13,4, 13,5, 13,6},
			{4,2, 6,2, 6,3, 6,4, 4,4}};	
	
	private double[] outer16 = new double[] {10,2, 11,6, 10,6};
	
	private double[] outer17 = new double[] {
		37.6083515	,
		55.752112	,
		37.6083476	,
		55.7521629	,
		37.6082996	,
		55.7521617	,
		37.6082976	,
		55.7521887	,
		37.6083455	,
		55.7521898	,
		37.6083435	,
		55.7522161	,
		37.6056999	,
		55.7521525	,
		37.6057019	,
		55.7521263	,
		37.6057495	,
		55.7521274	,
		37.6057538	,
		55.7520712	,
		37.6057574	,
		55.7520227	,
		37.6057101	,
		55.7520215	,
		37.6057121	,
		55.7519952	,
		37.6069349	,
		55.7520247	,
		37.6083555	,
		55.7520589	,
		37.6083535	,
		55.7520851	,
		37.6083062	,
		55.7520839	,
		37.6083041	,
		55.7521109	};

	private double[][] inners17 = new double[][] {
	{	37.6065067	,
		55.7521456	,
		37.6064592	,
		55.7521444	,
		37.6064612	,
		55.7521174	,
		37.6065087	,
		55.7521185	},

	{	37.6066149	,
		55.7521482	,
		37.6065674	,
		55.752147	,
		37.6065694	,
		55.75212	,
		37.6066169	,
		55.7521211	},

	{	37.6074802	,
		55.752169	,
		37.6074327	,
		55.7521679	,
		37.6074347	,
		55.7521408	,
		37.6074822	,
		55.752142	},

	{	37.607372	,
		55.7521664	,
		37.6073245	,
		55.7521653	,
		37.6073266	,
		55.7521382	,
		37.6073741	,
		55.7521394	},

	{	37.6072638	,
		55.7521638	,
		37.6072163	,
		55.7521627	,
		37.6072184	,
		55.7521356	,
		37.6072659	,
		55.7521368	},

	{	37.6071557	,
		55.7521612	,
		37.6071082	,
		55.7521601	,
		37.6071102	,
		55.752133	,
		37.6071577	,
		55.7521342	},

	{	37.6070475	,
		55.7521586	,
		37.607	,
		55.7521575	,
		37.6070021	,
		55.7521304	,
		37.6070496	,
		55.7521316	},

	{	37.6069394	,
		55.752156	,
		37.6068919	,
		55.7521549	,
		37.6068939	,
		55.7521278	,
		37.6069414	,
		55.752129	},

	{	37.606723	,
		55.7521508	,
		37.6066755	,
		55.7521497	,
		37.6066775	,
		55.7521226	,
		37.6067251	,
		55.7521238	},

	{	37.6068312	,
		55.7521534	,
		37.6067837	,
		55.7521523	,
		37.6067857	,
		55.7521252	,
		37.6068332	,
		55.7521264	},

	{	37.6082374	,
		55.7521872	,
		37.6081899	,
		55.7521861	,
		37.6081919	,
		55.7521591	,
		37.6082394	,
		55.7521602	},

	{	37.6082434	,
		55.7521095	,
		37.6081959	,
		55.7521083	,
		37.6081979	,
		55.7520813	,
		37.6082455	,
		55.7520824	},

	{	37.6081292	,
		55.7521846	,
		37.6080817	,
		55.7521835	,
		37.6080837	,
		55.7521565	,
		37.6081312	,
		55.7521576	},

	{	37.6081352	,
		55.7521069	,
		37.6080877	,
		55.7521057	,
		37.6080898	,
		55.7520787	,
		37.6081373	,
		55.7520798	},

	{	37.608021	,
		55.752182	,
		37.6079735	,
		55.7521809	,
		37.6079755	,
		55.7521539	,
		37.608023	,
		55.752155	},

	{	37.6080271	,
		55.7521043	,
		37.6079796	,
		55.7521031	,
		37.6079816	,
		55.7520761	,
		37.6080291	,
		55.7520772	},

	{	37.6079129	,
		55.7521794	,
		37.6078654	,
		55.7521783	,
		37.6078674	,
		55.7521513	,
		37.6079149	,
		55.7521524	},

	{	37.6079189	,
		55.7521017	,
		37.6078714	,
		55.7521005	,
		37.6078735	,
		55.7520735	,
		37.607921	,
		55.7520746	},

	{	37.6078108	,
		55.7520991	,
		37.6077633	,
		55.7520979	,
		37.6077653	,
		55.7520709	,
		37.6078128	,
		55.752072	},

	{	37.6078047	,
		55.7521768	,
		37.6077572	,
		55.7521757	,
		37.6077592	,
		55.7521487	,
		37.6078067	,
		55.7521498	},

	{	37.6075884	,
		55.7521716	,
		37.6075409	,
		55.7521705	,
		37.6075429	,
		55.7521435	,
		37.6075904	,
		55.7521446	},

	{	37.6077026	,
		55.7520965	,
		37.6076551	,
		55.7520953	,
		37.6076571	,
		55.7520683	,
		37.6077046	,
		55.7520694	},

	{	37.6075944	,
		55.7520939	,
		37.6075469	,
		55.7520927	,
		37.6075489	,
		55.7520657	,
		37.6075964	,
		55.7520668	},

	{	37.6076965	,
		55.7521742	,
		37.607649	,
		55.7521731	,
		37.6076511	,
		55.7521461	,
		37.6076986	,
		55.7521472	},

	{	37.6074863	,
		55.7520912	,
		37.6074388	,
		55.7520901	,
		37.6074408	,
		55.7520631	,
		37.6074883	,
		55.7520642	},

	{	37.6073781	,
		55.7520886	,
		37.6073306	,
		55.7520875	,
		37.6073326	,
		55.7520605	,
		37.6073801	,
		55.7520616	},

	{	37.6072699	,
		55.752086	,
		37.6072224	,
		55.7520849	,
		37.6072244	,
		55.7520579	,
		37.6072719	,
		55.752059	},

	{	37.6071617	,
		55.7520834	,
		37.6071142	,
		55.7520823	,
		37.6071163	,
		55.7520553	,
		37.6071638	,
		55.7520564	},

	{	37.6070536	,
		55.7520808	,
		37.6070061	,
		55.7520797	,
		37.6070081	,
		55.7520527	,
		37.6070556	,
		55.7520538	},

	{	37.6069454	,
		55.7520782	,
		37.6068979	,
		55.7520771	,
		37.6069	,
		55.7520501	,
		37.6069475	,
		55.7520512	},

	{	37.6068373	,
		55.7520756	,
		37.6067897	,
		55.7520745	,
		37.6067918	,
		55.7520475	,
		37.6068393	,
		55.7520486	},

	{	37.6067291	,
		55.752073	,
		37.6066816	,
		55.7520719	,
		37.6066836	,
		55.7520449	,
		37.6067311	,
		55.752046	},

	{	37.6066209	,
		55.7520704	,
		37.6065734	,
		55.7520693	,
		37.6065755	,
		55.7520422	,
		37.606623	,
		55.7520434	},

	{	37.6065128	,
		55.7520678	,
		37.6064653	,
		55.7520667	,
		37.6064673	,
		55.7520396	,
		37.6065148	,
		55.7520408	},

	{	37.6064046	,
		55.7520652	,
		37.6063571	,
		55.7520641	,
		37.6063591	,
		55.752037	,
		37.6064066	,
		55.7520382	},

	{	37.6063985	,
		55.752143	,
		37.606351	,
		55.7521418	,
		37.6063531	,
		55.7521148	,
		37.6064006	,
		55.7521159	}};
	
	private double[] outer18 = new double[] {
		39.0011842	,
		44.1629818	,
		39.00153	,
		44.1628459	,
		39.0012812	,
		44.1624676	,
		38.9996079	,
		44.1631234	,
		38.9999797	,
		44.1636482	,
		39.0003527	,
		44.1641362	,
		39.0005941	,
		44.1643595	,
		39.0011693	,
		44.1648106	,
		39.0012787	,
		44.1647512	,
		39.0011882	,
		44.1646434	,
		39.0013773	,
		44.1645428	,
		39.0016649	,
		44.1643898	,
		39.001728	,
		44.1644155	,
		39.0018293	,
		44.1643452	,
		39.0019258	,
		44.1642525	,
		39.0019974	,
		44.1641496	,
		39.0020368	,
		44.1640155	,
		39.0020333	,
		44.1638869	,
		39.0019997	,
		44.1637852	,
		39.0019672	,
		44.1637124	,
		39.0018936	,
		44.1636096	,
		39.0017777	,
		44.1635591	,
		39.0012909	,
		44.1630605	,
		39.0012455	,
		44.1630743	,
		39.0012322	,
		44.1630509	,
		39.0012176	,
		44.1630286	};
	
	private double[][] inners18 = new double[][] {
	{	39.000087	,
		44.1631616	,
		39.0001353	,
		44.1631789	,
		39.0002292	,
		44.1631575	,
		39.0001922	,
		44.1630576	,
		39.0000642	,
		44.1630841	,
		39.0000727	,
		44.1631129	},

	{	39.0002263	,
		44.163333	,
		39.0002647	,
		44.1633432	,
		39.0003003	,
		44.1633411	,
		39.0003415	,
		44.1633269	,
		39.0003742	,
		44.1632963	,
		39.0003813	,
		44.1632667	,
		39.0003714	,
		44.163233	,
		39.0003415	,
		44.1631973	,
		39.0003088	,
		44.163182	,
		39.000259	,
		44.1631841	,
		39.0002249	,
		44.1631953	,
		39.0002007	,
		44.1632238	,
		39.0001822	,
		44.1632361	,
		39.0001424	,
		44.1632412	,
		39.0001723	,
		44.1633155	,
		39.0001919	,
		44.163316	,
		39.000213	,
		44.1633228	},

	{	39.0004875	,
		44.1635709	,
		39.0004685	,
		44.1636134	,
		39.0004297	,
		44.163638	,
		39.000393	,
		44.163632	,
		39.00037	,
		44.1636534	,
		39.0003585	,
		44.1636914	,
		39.0003402	,
		44.1637062	,
		39.0003148	,
		44.1637129	,
		39.0002854	,
		44.1637126	,
		39.0002596	,
		44.1637062	,
		39.0002444	,
		44.1636888	,
		39.0002388	,
		44.1636699	,
		39.0002418	,
		44.1636535	,
		39.0002549	,
		44.1636402	,
		39.0003079	,
		44.1636155	,
		39.0003525	,
		44.1635749	,
		39.0003562	,
		44.1635395	,
		39.0003562	,
		44.1634867	,
		39.0003677	,
		44.1634603	,
		39.0003953	,
		44.1634355	,
		39.0004285	,
		44.1634249	,
		39.0004643	,
		44.163424	,
		39.0004932	,
		44.1634295	,
		39.0005173	,
		44.1634392	,
		39.0005316	,
		44.1634563	,
		39.0005403	,
		44.1634702	,
		39.0005456	,
		44.1634926	,
		39.0005426	,
		44.1635148	,
		39.0005316	,
		44.1635327	,
		39.000515	,
		44.1635478	},

	{	39.0009408	,
		44.1639533	,
		39.001037	,
		44.1640721	,
		39.0011547	,
		44.1640219	,
		39.0011325	,
		44.1639956	,
		39.0011662	,
		44.1639806	,
		39.0013635	,
		44.1642423	,
		39.001425	,
		44.1642237	,
		39.0012283	,
		44.1639575	,
		39.0012616	,
		44.1639426	,
		39.0013123	,
		44.1639509	,
		39.0013467	,
		44.163988	,
		39.0014493	,
		44.1639426	,
		39.0014906	,
		44.1638403	,
		39.0014364	,
		44.1637634	,
		39.0014998	,
		44.1637204	,
		39.0015086	,
		44.1636642	,
		39.0014626	,
		44.1636165	,
		39.0013972	,
		44.163607	,
		39.0013737	,
		44.1635852	,
		39.0013767	,
		44.1635606	,
		39.0013839	,
		44.1635091	,
		39.0013461	,
		44.1635246	,
		39.0013394	,
		44.1635625	,
		39.0013353	,
		44.1635908	,
		39.0013756	,
		44.1636307	,
		39.0014455	,
		44.1636433	,
		39.0014689	,
		44.1636683	,
		39.0014625	,
		44.1637088	,
		39.0014162	,
		44.1637363	,
		39.0013955	,
		44.1637162	,
		39.0013531	,
		44.1637113	,
		39.0013145	,
		44.163683	,
		39.001128	,
		44.1636587	,
		39.0010803	,
		44.1636826	,
		39.0010216	,
		44.1636722	,
		39.0009946	,
		44.163637	,
		39.0010065	,
		44.1636006	,
		39.0010516	,
		44.1635837	,
		39.0011151	,
		44.1635949	,
		39.0011386	,
		44.1636257	,
		39.0012233	,
		44.1636376	,
		39.0012823	,
		44.1635986	,
		39.0012974	,
		44.1635443	,
		39.0012615	,
		44.1635247	,
		39.001249	,
		44.1635861	,
		39.0012205	,
		44.1636072	,
		39.0011668	,
		44.1635986	,
		39.0011348	,
		44.1635635	,
		39.001058	,
		44.1635498	,
		39.0009665	,
		44.1635804	,
		39.0009463	,
		44.1636354	,
		39.0009931	,
		44.1637001	,
		39.0010853	,
		44.1637168	,
		39.001149	,
		44.1636889	,
		39.0012923	,
		44.163708	,
		39.0013208	,
		44.1637281	,
		39.0013166	,
		44.1637466	,
		39.0012018	,
		44.163804	,
		39.0011869	,
		44.1638469	},

	{	39.0013767	,
		44.1635606	,
		39.0014505	,
		44.1635218	,
		39.0014482	,
		44.163436	,
		39.0013548	,
		44.1633951	,
		39.0012461	,
		44.1634347	,
		39.0012412	,
		44.163514	,
		39.0012615	,
		44.1635247	,
		39.0012974	,
		44.1635443	,
		39.0013394	,
		44.1635625	,
		39.0013461	,
		44.1635246	,
		39.0012983	,
		44.1635023	,
		39.0012981	,
		44.1634563	,
		39.0013507	,
		44.163437	,
		39.0014008	,
		44.1634583	,
		39.0014007	,
		44.1635005	,
		39.0013839	,
		44.1635091	}};

	private double[] outer19 = new double[] {0,0, 0,12, 8,12, 8,0};
	
	private double[][] inners19 = new double[][] {
			{1,5, 2,6, 3,7, 4,8, 4,7, 3,6, 3,4, 4,3, 6,4, 6,5, 5,6, 5,8, 7,6, 7,3, 4,1, 1,3},
			{1,11, 6,11, 6,10, 5,9, 5,8, 5,6, 4,7, 4,8, 4,9, 5,10, 3,10, 2,9, 3,7, 2,6, 1,8}};
	
	private double[] outer20 = new double[] {
		12.4711016	,
		41.895291	,
		12.4710974	,
		41.8952928	,
		12.4710918	,
		41.8952916	,
		12.4710882	,
		41.89529	,
		12.471084	,
		41.8952927	,
		12.4710764	,
		41.8952928	,
		12.4710702	,
		41.8952921	,
		12.4710656	,
		41.895289	,
		12.4710596	,
		41.8952857	,
		12.4710566	,
		41.8952833	,
		12.4710485	,
		41.8952856	,
		12.4710436	,
		41.8952856	,
		12.4710383	,
		41.8952849	,
		12.4710321	,
		41.8952811	,
		12.4710284	,
		41.8952769	,
		12.4710279	,
		41.8952729	,
		12.4710285	,
		41.8952693	,
		12.4710323	,
		41.8952634	,
		12.4710293	,
		41.895261	,
		12.4710254	,
		41.8952563	,
		12.4710216	,
		41.8952526	,
		12.4710213	,
		41.8952479	,
		12.4710221	,
		41.8952423	,
		12.4710261	,
		41.8952394	,
		12.4710242	,
		41.8952366	,
		12.4710232	,
		41.8952323	,
		12.4710259	,
		41.8952294	,
		12.4710304	,
		41.8952276	,
		12.471036	,
		41.8952288	,
		12.4710396	,
		41.8952305	,
		12.4710438	,
		41.8952278	,
		12.4710514	,
		41.8952278	,
		12.4710576	,
		41.8952285	,
		12.4710622	,
		41.8952317	,
		12.4710681	,
		41.8952351	,
		12.471071	,
		41.8952376	,
		12.4710792	,
		41.8952354	,
		12.4710841	,
		41.8952354	,
		12.4710893	,
		41.8952361	,
		12.4710946	,
		41.8952393	,
		12.4710983	,
		41.8952434	,
		12.4710988	,
		41.8952474	,
		12.4710983	,
		41.895251	,
		12.4710946	,
		41.8952569	,
		12.4710976	,
		41.8952593	,
		12.4711016	,
		41.8952639	,
		12.4711055	,
		41.8952676	,
		12.4711059	,
		41.8952723	,
		12.4711052	,
		41.8952779	,
		12.4711012	,
		41.8952808	,
		12.4711031	,
		41.8952836	,
		12.4711043	,
		41.8952879	};
	
	private double[] outer21 = new double[] {
				30.3092241	,
				59.9402124	,
				30.3092422	,
				59.940219	,
				30.3092602	,
				59.9402257	,
				30.3093005	,
				59.9401984	,
				30.3093132	,
				59.9401878	,
				30.3093226	,
				59.9401745	,
				30.3093267	,
				59.9401605	,
				30.3093253	,
				59.9401464	,
				30.3093185	,
				59.9401328	,
				30.3093063	,
				59.94012	,
				30.3092896	,
				59.9401087	,
				30.3092713	,
				59.9401004	,
				30.3094584	,
				59.9399783	,
				30.3094819	,
				59.9399579	,
				30.309494	,
				59.9399351	,
				30.3094939	,
				59.9399115	,
				30.3094814	,
				59.9398888	,
				30.3094576	,
				59.9398684	,
				30.309424	,
				59.9398519	,
				30.3094409	,
				59.9398594	,
				30.3093217	,
				59.9398133	,
				30.3093056	,
				59.939824	,
				30.3092894	,
				59.9398348	,
				30.3093916	,
				59.9398734	,
				30.3094191	,
				59.9398876	,
				30.3094363	,
				59.9399054	,
				30.3094416	,
				59.9399251	,
				30.3094345	,
				59.9399445	,
				30.3094157	,
				59.9399619	,
				30.3091843	,
				59.9401128	,
				30.3092258	,
				59.9401282	,
				30.3092362	,
				59.9401329	,
				30.3092446	,
				59.9401386	,
				30.3092506	,
				59.940145	,
				30.309254	,
				59.9401518	,
				30.3092547	,
				59.9401588	,
				30.3092527	,
				59.9401658	,
				30.309248	,
				59.9401724	,
				30.3092407	,
				59.9401785	,
				30.3092025	,
				59.9402043		};
	
	private double[] outer22 = new double[] {
		-73.9900866	,
		40.7218471	,
		-73.9899738	,
		40.7218151	,
		-73.9900296	,
		40.7217081	,
		-73.9897064	,
		40.7216106	,
		-73.9895207	,
		40.7215545	,
		-73.9894988	,
		40.7215991	,
		-73.9894634	,
		40.7216714	,
		-73.9893914	,
		40.7216496	,
		-73.9893808	,
		40.7216465	,
		-73.9894229	,
		40.7215718	,
		-73.9894815	,
		40.7214681	,
		-73.9897429	,
		40.7215323	,
		-73.9897959	,
		40.7214285	,
		-73.9898046	,
		40.7214115	,
		-73.9898078	,
		40.7214051	,
		-73.9898046	,
		40.7214115	,
		-73.9898857	,
		40.7212783	,
		-73.9900217	,
		40.7209954	,
		-73.9900785	,
		40.720893	,
		-73.9902619	,
		40.7209472	,
		-73.9902541	,
		40.7209624	,
		-73.990392	,
		40.7210031	,
		-73.9903786	,
		40.7210256	,
		-73.9902309	,
		40.7209856	,
		-73.989977	,
		40.7214979	,
		-73.9902225	,
		40.721569	};

	private double[] outer23 = new double[] {
		20.5119038	,
		54.7477421	,
		20.5120046	,
		54.7475422	,
		20.5118702	,
		54.747442	,
		20.5117407	,
		54.7473751	,
		20.5114061	,
		54.7472346	,
		20.5109536	,
		54.7471599	,
		20.5104413	,
		54.7468589	,
		20.5100494	,
		54.7467578	,
		20.5096096	,
		54.7467592	,
		20.50943	,
		54.7467845	,
		20.5092574	,
		54.7468195	,
		20.5091707	,
		54.7468676	,
		20.5091029	,
		54.7469244	,
		20.5091726	,
		54.7470934	,
		20.5092665	,
		54.7472473	,
		20.5094616	,
		54.7473957	,
		20.5097179	,
		54.7474656	,
		20.5097665	,
		54.7474891	,
		20.5098214	,
		54.7475264	,
		20.5100439	,
		54.7476945	,
		20.5101296	,
		54.7478095	,
		20.5102332	,
		54.7478533	,
		20.5101544	,
		54.7479406	,
		20.5100673	,
		54.7479678	,
		20.5100262	,
		54.7480201	,
		20.5098514	,
		54.7481499	,
		20.509819	,
		54.748259	,
		20.5099005	,
		54.7485644	,
		20.5100469	,
		54.7487945	,
		20.5103622	,
		54.7491114	,
		20.5105083	,
		54.749158	,
		20.5106451	,
		54.7492137	,
		20.5109258	,
		54.7492177	,
		20.5110796	,
		54.7491854	,
		20.5114597	,
		54.7491088	,
		20.5115736	,
		54.7489667	,
		20.5114674	,
		54.7488069	,
		20.5114998	,
		54.7484674	,
		20.5115918	,
		54.7482234	,
		20.511634	,
		54.7481583	,
		20.5117001	,
		54.7480563	,
		20.5116803	,
		54.7480869	,
		20.5117246	,
		54.7480185	,
		20.5117529	,
		54.7479749	,
		20.5118318	,
		54.7478532	,
		20.511883	,
		54.7477742	};

	private double[] outer24 = new double[] {
		19.9548007	,
		54.913104	,
		19.9548	,
		54.9131029	,
		19.9548705,	
		54.9131317	,
		19.9549858	,
		54.9131533	,
		19.955195	,
		54.9131333	,
		19.9553318	,
		54.9130716	,
		19.9553264	,
		54.9129899	,
		19.955254	,
		54.9129375	,
		19.9551494	,
		54.9129082	,
		19.9550609	,
		54.9129128	,
		19.9550019	,
		54.9129498	,
		19.9549026	,
		54.912956	,
		19.9547712	,
		54.9129652	,
		19.9547632	,
		54.9130315	,
		19.9547846	,
		54.9130793	,
		19.9548	,
		54.9131029	};

	private double[] outer25 = new double[] {
				21.0532673	,
				54.6320567	,
				21.0534872	,
				54.6321778	,
				21.053616	,
				54.6321498	,
				21.0538842	,
				54.6320381	,
				21.0540344	,
				54.6320039	,
				21.0543295	,
				54.6320349	,
				21.0552736	,
				54.6322585	,
				21.0555365	,
				54.6321964	,
				21.0562821	,
				54.6319791	,
				21.0578646	,
				54.6314916	,
				21.0584815	,
				54.6312509	,
				21.0592057	,
				54.6310584	,
				21.0600157	,
				54.6307945	,
				21.0606648	,
				54.6306175	,
				21.0612925	,
				54.6304436	,
				21.0621615	,
				54.6302293	,
				21.0634382	,
				54.6298722	,
				21.0641034	,
				54.6298815	,
				21.0656484	,
				54.629984	,
				21.0672309	,
				54.6299933	,
				21.0674769	,
				54.6296811	,
				21.0677232	,
				54.6292039	,
				21.0678592	,
				54.628762	,
				21.0681359	,
				54.6273996	,
				21.0680826	,
				54.62731	,
				21.0678533	,
				54.6272849	,
				21.0678962	,
				54.6272127	,
				21.0681839	,
				54.627109	,
				21.0682277	,
				54.6269477	,
				21.068345	,
				54.6263702	,
				21.0683735	,
				54.6255216	,
				21.068688	,
				54.6246814	,
				21.0686203	,
				54.6243352	,
				21.0684271	,
				54.6242358	,
				21.0686954	,
				54.6236706	,
				21.0688241	,
				54.622888	,
				21.0690065	,
				54.6223476	,
				21.0691138	,
				54.6217575	,
				21.0693176	,
				54.6210245	,
				21.0693927	,
				54.6205089	,
				21.069146	,
				54.6203846	,
				21.0687061	,
				54.6203474	,
				21.0681053	,
				54.6204343	,
				21.0680409	,
				54.6207884	,
				21.0680731	,
				54.6213475	,
				21.067998	,
				54.6217512	,
				21.0678371	,
				54.6218196	,
				21.0671397	,
				54.621832	,
				21.0664423	,
				54.621863	,
				21.0662063	,
				54.6220432	,
				21.0660453	,
				54.62236	,
				21.0659381	,
				54.6227575	,
				21.0656698	,
				54.6229563	,
				21.0654553	,
				54.6232793	,
				21.0651978	,
				54.6234222	,
				21.0649295	,
				54.6237824	,
				21.0650476	,
				54.6239625	,
				21.0651656	,
				54.6241116	,
				21.0648866	,
				54.6243539	,
				21.0645326	,
				54.6244657	,
				21.0641249	,
				54.6244657	,
				21.0638674	,
				54.624329	,
				21.0640283	,
				54.6240992	,
				21.0639854	,
				54.6239439	,
				21.0636528	,
				54.6239625	,
				21.0632773	,
				54.6240992	,
				21.0630735	,
				54.6240371	,
				21.0627731	,
				54.623888	,
				21.062655	,
				54.6237762	,
				21.0625156	,
				54.6236458	,
				21.0627623	,
				54.6233725	,
				21.0627838	,
				54.6230557	,
				21.0626336	,
				54.6227948	,
				21.0625477	,
				54.6225774	,
				21.0621293	,
				54.6225215	,
				21.061786	,
				54.6224718	,
				21.0611101	,
				54.6225153	,
				21.0604449	,
				54.6225215	,
				21.0597904	,
				54.6225153	,
				21.0594364	,
				54.6224594	,
				21.0593506	,
				54.6222854	,
				21.05949	,
				54.6221985	,
				21.059592	,
				54.622169	,
				21.0595598	,
				54.6220882	,
				21.0594954	,
				54.621874	,
				21.0594552	,
				54.6216006	,
				21.0595115	,
				54.621436	,
				21.0579236	,
				54.6218444	,
				21.0570868	,
				54.6220991	,
				21.0561426	,
				54.6223103	,
				21.0559924	,
				54.6224345	,
				21.0558851	,
				54.6225463	,
				21.0556384	,
				54.6226768	,
				21.0557457	,
				54.6227637	,
				21.0562392	,
				54.622714	,
				21.0565611	,
				54.6227699	,
				21.0566362	,
				54.6229501	,
				21.0567327	,
				54.6231302	,
				21.056899	,
				54.623198,
				21.0570224,	
				54.6232482	,
				21.0573228	,
				54.6232669	,
				21.0575481	,
				54.6233725	,
				21.058106	,
				54.6235899	,
				21.0583679	,
				54.6237178	,
				21.0584493	,
				54.6237576	,
				21.058711	,
				54.623883	,
				21.0589482	,
				54.6239967	,
				21.0591521	,
				54.6239936	,
				21.0595812	,
				54.6240464	,
				21.0598387	,
				54.6240402	,
				21.0600372	,
				54.6239874	,
				21.0601767	,
				54.624065	,
				21.0603215	,
				54.6241737	,
				21.0603376	,
				54.6243104	,
				21.0604127	,
				54.6244501	,
				21.0606005	,
				54.624593	,
				21.0613515	,
				54.6248042	,
				21.0619684	,
				54.6250371	,
				21.0623546	,
				54.6251644	,
				21.0628213	,
				54.6252855	,
				21.0629393	,
				54.6254315	,
				21.0629527	,
				54.6254761	,
				21.0635402	,
				54.6256147	,
				21.0638889	,
				54.6256924	,
				21.0642805	,
				54.6256799	,
				21.0647418	,
				54.625565	,
				21.0651656	,
				54.6255154	,
				21.0656377	,
				54.6254563	,
				21.0656698	,
				54.6255371	,
				21.0652085	,
				54.6256675	,
				21.0647203	,
				54.6257141	,
				21.0642483	,
				54.6257483	,
				21.0634275	,
				54.6256644	,
				21.0629527	,
				54.6254761	,
				21.0627462	,
				54.6253942	,
				21.0617753	,
				54.6251023	,
				21.0598763	,
				54.6244315	,
				21.0591038	,
				54.6242172	,
				21.0587176	,
				54.6240619	,
				21.0585942	,
				54.6239532	,
				21.0585942	,
				54.6238787	,
				21.0584762	,
				54.6238259	,
				21.0581972	,
				54.6238042	,
				21.0580577	,
				54.6236861	,
				21.0578432	,
				54.6235868	,
				21.0575803	,
				54.6234998	,
				21.0573496	,
				54.6235122	,
				21.0574784	,
				54.6236395	,
				21.0577788	,
				54.6237638	,
				21.0578807	,
				54.6239346	,
				21.0580148	,
				54.6242358	,
				21.0581757	,
				54.6246427	,
				21.0582562	,
				54.6247234	,
				21.0585566	,
				54.624829	,
				21.0588141	,
				54.6249843	,
				21.0590072	,
				54.6253414	,
				21.0595544	,
				54.6264936	,
				21.0596349	,
				54.6265122	,
				21.0597743	,
				54.626506	,
				21.0599138	,
				54.6265557	,
				21.0598924	,
				54.6266023	,
				21.0596456	,
				54.6266458	,
				21.0596885	,
				54.6267917	,
				21.0597475	,
				54.6271209	,
				21.0597743	,
				54.6273538	,
				21.0598602	,
				54.6276209	,
				21.058975	,
				54.6277327	,
				21.0578861	,
				54.6278165	,
				21.0575857	,
				54.6277544	,
				21.0573496	,
				54.6270339	,
				21.0562982	,
				54.6243476	,
				21.0566201	,
				54.6242234	,
				21.0568588	,
				54.6241815	,
				21.0570492	,
				54.6240961	,
				21.056891	,
				54.6239889	,
				21.0568078	,
				54.6239144	,
				21.0569071	,
				54.6238538	,
				21.0569983	,
				54.6237622	,
				21.0570063	,
				54.6236815	,
				21.0568936	,
				54.6235883	,
				21.0569527	,
				54.6234051	,
				21.0568346	,
				54.6232964	,
				21.0566201	,
				54.6232311	,
				21.0564001	,
				54.6232436	,
				21.0562446	,
				54.6231939	,
				21.0559227	,
				54.6232094	,
				21.055633	,
				54.6233181	,
				21.055338	,
				54.6233398	,
				21.0553326	,
				54.6234423	,
				21.0550483	,
				54.6235448	,
				21.0549571	,
				54.6236691	,
				21.0550751	,
				54.6237467	,
				21.0547425	,
				54.6237902	,
				21.0545977	,
				54.6238647	,
				21.0549732	,
				54.6239175	,
				21.0552951	,
				54.6238181	,
				21.0556116	,
				54.6237343	,
				21.055971	,
				54.6237281	,
				21.0561641	,
				54.6236473	,
				21.0563197	,
				54.6236256	,
				21.0560353	,
				54.6238212	,
				21.0555847	,
				54.6239175	,
				21.0551341	,
				54.6240076	,
				21.0546889	,
				54.6241287	,
				21.0543777	,
				54.6241504	,
				21.0539969	,
				54.6240728	,
				21.053616	,
				54.6239579	,
				21.0535409	,
				54.6238119	,
				21.0540934	,
				54.623756	,
				21.0541524	,
				54.6235697	,
				21.0540881	,
				54.6234175	,
				21.05397	,
				54.6234206	,
				21.0535677	,
				54.6236566	,
				21.0533424	,
				54.6237653	,
				21.0530098	,
				54.6239641	,
				21.052865	,
				54.6240976	,
				21.0528435	,
				54.6242684	,
				21.052704	,
				54.6243337	,
				21.0526429	,
				54.6242871	,
				21.0526021	,
				54.624256	,
				21.0525431	,
				54.624166	,
				21.0521998	,
				54.6241194	,
				21.0518618	,
				54.6241132	,
				21.0517116	,
				54.6242902	,
				21.0516794	,
				54.6243523	,
				21.0518189	,
				54.6244579	,
				21.0519637	,
				54.6245417	,
				21.0520979	,
				54.6246411	,
				21.0522802	,
				54.6247095	,
				21.0523285	,
				54.6246815	,
				21.0524358	,
				54.6245573	,
				21.0524841	,
				54.6246846	,
				21.0526558	,
				54.6248057	,
				21.0528918	,
				54.6248244	,
				21.0530313	,
				54.6247902	,
				21.0531707	,
				54.6247436	,
				21.0533049	,
				54.6248399	,
				21.0533531	,
				54.6247964	,
				21.0534712	,
				54.6247654	,
				21.0535463	,
				54.6248275	,
				21.0534497	,
				54.6249424	,
				21.0533853	,
				54.6250728	,
				21.0534175	,
				54.6251753	,
				21.0533585	,
				54.6252685	,
				21.0532619	,
				54.6253523	,
				21.053219	,
				54.6254455	,
				21.0533209	,
				54.6256287	,
				21.0532888	,
				54.6256877	,
				21.0531225	,
				54.6256504	,
				21.0530527	,
				54.6255169	,
				21.0530366	,
				54.625343	,
				21.0530849	,
				54.6251846	,
				21.0530205	,
				54.6251256	,
				21.0529347	,
				54.6250231	,
				21.052865	,
				54.6249672	,
				21.0526987	,
				54.6249424	,
				21.0525521	,
				54.6249188	,
				21.0525056	,
				54.6249113	,
				21.0523714	,
				54.6249113	,
				21.0521408	,
				54.6249548	,
				21.051953	,
				54.6250542	,
				21.0517063	,
				54.6251101	,
				21.0516204	,
				54.6251877	,
				21.0515292	,
				54.6252157	,
				21.0512503	,
				54.6250977	,
				21.0514434	,
				54.624902	,
				21.0514541	,
				54.6247809	,
				21.0513737	,
				54.6247188	,
				21.0512396	,
				54.6246784	,
				21.0511001	,
				54.6247001	,
				21.0507138	,
				54.6248119	,
				21.0505744	,
				54.6248958	,
				21.0502686	,
				54.6249579	,
				21.0500862	,
				54.6250418	,
				21.0499575	,
				54.6251194	,
				21.0493727	,
				54.6253244	,
				21.048965	,
				54.6254486	,
				21.048611	,
				54.6255417	,
				21.0482033	,
				54.6256287	,
				21.0477098	,
				54.6256722	,
				21.0476132	,
				54.6255728	,
				21.0475059	,
				54.6257716	,
				21.0474737	,
				54.6259082	,
				21.0471304	,
				54.6259144	,
				21.0467442	,
				54.6260448	,
				21.0464438	,
				54.6262747	,
				21.0461863	,
				54.626343	,
				21.0463901	,
				54.626492	,
				21.0464974	,
				54.6267343	,
				21.0468622	,
				54.6268957	,
				21.0471411	,
				54.6269516	,
				21.0474094	,
				54.6270945	,
				21.0477956	,
				54.6274112	,
				21.0480102	,
				54.6276286	,
				21.0481711	,
				54.6277963	,
				21.0482355	,
				54.6279889	,
				21.0478278	,
				54.6280572	,
				21.0471733	,
				54.6279764	,
				21.0467978	,
				54.6279267	,
				21.0463472	,
				54.6279392	,
				21.0460253	,
				54.6279764	,
				21.0464759	,
				54.6282932	,
				21.0469266	,
				54.6284547	,
				21.047227	,
				54.6286223	,
				21.0476454	,
				54.6288583	,
				21.0481496	,
				54.6291254	,
				21.048729	,
				54.6294918	,
				21.0492118	,
				54.6298272	,
				21.0496517	,
				54.6299638	,
				21.0496946	,
				54.6301688	,
				21.0497099	,
				54.6303217	,
				21.0502632	,
				54.6304172	,
				21.0516258	,
				54.6311686	,
				21.0522159	,
				54.6315599	,
				21.0526343	,
				54.6317772	,
				21.052983	,
				54.6318921	,
				21.0531547	,
				54.6319853	

	};
	
	private double[] outer26 = new double[] {
		76.7056227	,
		66.1170347	,
		76.7076502	,
		66.1176103	,
		76.7104518	,
		66.1180845	,
		76.7118059	,
		66.118621	,
		76.7121011	,
		66.1188069	,
		76.7122726	,
		66.119046	,
		76.7126175	,
		66.1191487	,
		76.7128635	,
		66.1193014	,
		76.7129619	,
		66.1194275	,
		76.713134	,
		66.1196764	,
		76.7131176	,
		66.1198158	,
		76.713339	,
		66.1200149	,
		76.713202	,
		66.1204257	,
		76.7132001	,
		66.120525	,
		76.7130494	,
		66.120748	,
		76.7128117	,
		66.1209345	,
		76.7124366	,
		66.1210993	,
		76.7116278	,
		66.1212754	,
		76.7105334	,
		66.1215409	,
		76.7101399	,
		66.1216139	,
		76.7096726	,
		66.1216289	,
		76.7088831	,
		66.1216484	,
		76.7084483	,
		66.1216459	,
		76.7081928	,
		66.1216289	,
		76.7079944	,
		66.1216361	,
		76.7058833	,
		66.1217752	,
		76.7053696	,
		66.121792	,
		76.7040306	,
		66.1217826	,
		76.7035436	,
		66.1217873	,
		76.7027552	,
		66.1218225	,
		76.7024422	,
		66.1218835	,
		76.7019842	,
		66.1219351	,
		76.7016364	,
		66.1220102	,
		76.7011448	,
		66.1220873	,
		76.7005179	,
		66.1222739	,
		76.7001237	,
		66.1225602	,
		76.6999382	,
		66.1230389	,
		76.6996483	,
		66.1235082	,
		76.699428	,
		66.1237663	,
		76.6995208	,
		66.124015	,
		76.6991846	,
		66.1244796	,
		76.6988367	,
		66.1247095	,
		76.6979092	,
		66.1258639	,
		76.6973527	,
		66.1263894	,
		76.6970281	,
		66.1268539	,
		76.6964601	,
		66.1274579	,
		76.6930346	,
		66.1285047	,
		76.6916041	,
		66.1290635	,
		76.6900137	,
		66.1292957	,
		76.6880953	,
		66.1295744	,
		76.6869476	,
		66.1301384	,
		76.6856687	,
		66.1303772	,
		76.6844551	,
		66.1307695	,
		76.6842206	,
		66.1309682	,
		76.6837482	,
		66.1313688	,
		76.6835287	,
		66.1315549	,
		76.6825121	,
		66.1320923	,
		76.6818359	,
		66.1326638	,
		76.6820947	,
		66.1339881	,
		76.6821275	,
		66.1342302	,
		76.682097	,
		66.1344826	,
		76.6824567	,
		66.1343682	,
		76.6826422	,
		66.1344034	,
		76.6829204	,
		66.1343799	,
		76.6828451	,
		66.134265	,
		76.6825726	,
		66.1341477	,
		76.6827349	,
		66.1339836	,
		76.6828813	,
		66.1339509	,
		76.682966	,
		66.1337628	,
		76.683294	,
		66.1337396	,
		76.683835	,
		66.1334146	,
		76.6844089	,
		66.1332288	,
		76.6846961	,
		66.1329896	,
		76.6851795	,
		66.1326814	,
		76.6858051	,
		66.1324475	,
		76.6864955	,
		66.1321893	,
		76.6871171	,
		66.1319568	,
		76.689049	,
		66.1314805	,
		76.6908155	,
		66.1309744	,
		76.6919048	,
		66.1305602	,
		76.6933519	,
		66.1302209	,
		76.6961344	,
		66.1296345	,
		76.6967945	,
		66.129074	,
		76.6970387	,
		66.1284099	,
		76.6972474	,
		66.1281519	,
		76.697742	,
		66.1280785	,
		76.6983101	,
		66.1280691	,
		76.6996821	,
		66.1278	,
		76.7008188	,
		66.1270791,	
		76.7015648	,
		66.1265117	,
		76.7015074	,
		66.1263624	,
		76.7013107	,
		66.1262728	,
		76.7013735	,
		66.1261636	,
		76.7006384	,
		66.126014	,
		76.7011139	,
		66.1256324	,
		76.7015197	,
		66.1256492	,
		76.7018476	,
		66.1255098	,
		76.7030469	,
		66.1244229	,
		76.7033971	,
		66.1244142	,
		76.7035692	,
		66.1243147	,
		76.7034093	,
		66.1242052	,
		76.7031839	,
		66.124099	,
		76.7035692	,
		66.1240625	,
		76.703725	,
		66.1240094	,
		76.7034093	,
		66.1239646	,
		76.702733	,
		66.1237622	,
		76.7034053	,
		66.123792	,
		76.7039955	,
		66.123875	,
		76.7046596	,
		66.1238667	,
		76.7051641	,
		66.1237001	,
		76.7056679	,
		66.1237539	,
		76.7063976	,
		66.1237257	,
		76.7070994	,
		66.1238012	,
		76.7072058	,
		66.1237236	,
		76.7070088	,
		66.1236767	,
		76.7070493	,
		66.1236368	,
		76.7071949	,
		66.1235702	,
		76.7070983	,
		66.1235297	,
		76.7070856	,
		66.1235005	,
		76.7070508	,
		66.1234841	,
		76.707074	,
		66.1234524	,
		76.7070595	,
		66.1234208	,
		76.7070145	,
		66.1234144	,
		76.7068856	,
		66.1234125	,
		76.7067517	,
		66.1234119	,
		76.7067059	,
		66.1233844	,
		76.7068116	,
		66.1233263	,
		76.7067768	,
		66.1232923	,
		76.7068034	,
		66.1232591	,
		76.7068321	,
		66.1232318	,
		76.7069182	,
		66.1232135	,
		76.7069975	,
		66.1231785	,
		76.7070991	,
		66.1231791	,
		76.7072091	,
		66.1231421	,
		76.7072787	,
		66.1231245	,
		76.7073888	,
		66.1231456	,
		76.7074526	,
		66.123162	,
		76.7075859	,
		66.1231667	,
		76.7077135	,
		66.1231925	,
		76.7079975	,
		66.1231702	,
		76.7080816	,
		66.1231667	,
		76.7082381	,
		66.1231914	,
		76.7083888	,
		66.1231573	,
		76.7084787	,
		66.1231034	,
		76.7085569	,
		66.123094	,
		76.7087134	,
		66.1231151	,
		76.7087793	,
		66.1231026	,
		76.7088244	,
		66.1230827	,
		76.7088572	,
		66.1230561	,
		76.7089389	,
		66.1230494	,
		76.7089853	,
		66.1230646	,
		76.7090693	,
		66.1230705	,
		76.7091737	,
		66.1230412	,
		76.7091911	,
		66.1229931	,
		76.7094084	,
		66.122972	,
		76.7095824	,
		66.1229239	,
		76.7096142	,
		66.1228781	,
		76.7096751	,
		66.1228546	,
		76.7097736	,
		66.122837	,
		76.7098171	,
		66.1228546	,
		76.7098055	,
		66.1228816	,
		76.7098693	,
		66.1228898	,
		76.7099095	,
		66.122874	,
		76.7099505	,
		66.122857	,
		76.709991	,
		66.1228159	,
		76.7101678	,
		66.1227502	,
		76.7103041	,
		66.122708	,
		76.7104693	,
		66.1226693	,
		76.7105968	,
		66.1226458	,
		76.7107388	,
		66.122661	,
		76.7108954	,
		66.1227303	,
		76.7110083	,
		66.1227865	,
		76.7110432	,
		66.1228617	,
		76.7111446	,
		66.1228429	,
		76.7112229	,
		66.1228218	,
		76.7113069	,
		66.1227584	,
		76.7115127	,
		66.1227373	,
		76.711642	,
		66.1226412	,
		76.7117837	,
		66.1224347	,
		76.7119821	,
		66.1222894	,
		76.7121521	,
		66.1221632	,
		76.7122597	,
		66.122133	,
		76.7122925	,
		66.1221031	,
		76.7123392	,
		66.122087	,
		76.7124032	,
		66.1221123	,
		76.712438	,
		66.1221435	,
		76.7123316	,
		66.1223391	,
		76.7127586	,
		66.1222153	,
		76.7127397	,
		66.1220814	,
		76.7127681	,
		66.1219763	,
		76.7129003	,
		66.1219285	,
		76.7130515	,
		66.1218367	,
		76.7130231	,
		66.1217736	,
		76.7131308	,
		66.1217316	,
		76.7130817	,
		66.1216216	,
		76.7131397	,
		66.1215113	,
		76.7133244	,
		66.1213704	,
		76.7136757	,
		66.1212581	,
		76.71375	,
		66.1211175	,
		76.7138282	,
		66.1208145	,
		76.7138405	,
		66.1206047	,
		76.7138357	,
		66.1204289	,
		76.7138671	,
		66.120402	,
		76.7139585	,
		66.1204097	,
		76.7141191	,
		66.1203953	,
		76.7142396	,
		66.1203523	,
		76.7142372	,
		66.1202815	,
		76.7140247	,
		66.1201745	,
		76.713746	,
		66.1198685	,
		76.7137661	,
		66.119723	,
		76.7136413	,
		66.1195288	,
		76.7135107	,
		66.1193154	,
		76.7135491	,
		66.1192437	,
		76.713659	,
		66.1192501	,
		76.7138016	,
		66.1191787	,
		76.7141581	,
		66.1191993	,
		76.7144934	,
		66.1192187	,
		76.7148808	,
		66.1190303	,
		76.7152031	,
		66.1191125	,
		76.7154808	,
		66.1191722	,
		76.7156699	,
		66.1192074	,
		76.7157911	,
		66.1191958	,
		76.7158352	,
		66.119159	,
		76.7159765	,
		66.1190015	,
		76.7160867	,
		66.1189366	,
		76.716292	,
		66.1189171	,
		76.7165843	,
		66.1189602	,
		76.716809	,
		66.1190416	,
		76.7169591	,
		66.1191827	,
		76.7170077	,
		66.1193715	,
		76.7170122	,
		66.1195108	,
		76.7171458	,
		66.1196451	,
		76.7174397	,
		66.119692	,
		76.7176702	,
		66.1197244	,
		76.7180843	,
		66.1197407	,
		76.7184317	,
		66.1197609	,
		76.7186694	,
		66.1197342	,
		76.7189101	,
		66.119673	,
		76.719093	,
		66.1196014	,
		76.7191621	,
		66.1194264	,
		76.7193268	,
		66.119381	,
		76.7195205	,
		66.1193512	,
		76.7198575	,
		66.1192516	,
		76.7199441	,
		66.1192383	,
		76.7200275	,
		66.11923	,
		76.7200511	,
		66.1192721	,
		76.7201194	,
		66.1195348	,
		76.7199128	,
		66.1197672	,
		76.7200735	,
		66.1200275	,
		76.7202572	,
		66.1197207	,
		76.7204067	,
		66.1175091	,
		76.7205557	,
		66.1153046	,
		76.7200965	,
		66.115379	,
		76.7190402	,
		66.1155277	,
		76.7162616	,
		66.1156765	,
		76.7151364	,
		66.1156579	,
		76.7133452	,
		66.1155649	,
		76.7128322	,
		66.1154503	,
		76.7102341	,
		66.1151544	,
		76.7091949	,
		66.115253	,
		76.7085292	,
		66.1155357	,
		76.7075874	,
		66.1157987	,
		76.7071003	,
		66.116134	,
		76.7064995	,
		66.1162852	,
		76.7057038	,
		66.1163838	,
		76.7053953	,
		66.1166928	};

	private double[][] inners26 = new double[][] {{
		76.6858051	,
		66.1324475	,
		76.6837482	,
		66.1313688	,
		76.6842206	,
		66.1309682	,
		76.6864955	,
		66.1321893	}};

	private double[] outer27 = new double[] {1,1, 4,1, 6,1, 9,1, 9,5, 6,5, 4,5, 1,5};	
	private double[][] inners27 = new double[][] {{4,1, 4,5, 6,5, 6,1}};
	
	private double[] outer28 = new double[] {1,1, 1,4, 3,4, 3,2, 3,1, 2,1};	
	private double[][] inners28 = new double[][] {{2,1, 3,1, 3,2, 2,2}};
	
	private double[] outer29 = new double[] {1,1, 1,2, 1,3, 1,4, 3,4, 5,4, 5,1, 3,1};	
	private double[][] inners29 = new double[][] {{1,3, 3,3, 3,4, 5,4, 5,1, 3,1, 3,2, 1,2}};
	
	private double[] outer30 = new double[] {1,1, 1,5, 3,5, 5,5, 5,1, 3,1};	
	private double[][] inners30 = new double[][] {{3,5, 5,5, 5,1, 3,1}};
	
	
	
	// Набор переменных для отрисовки
	public static int[] X;
	public static int[] Y;	
	public static ArrayList<Mj_Point[]> arrayPolygonPoints = new ArrayList<Mj_Point[]>();
	public static ArrayList<Mj_Point[]> arrayTrianglesPoints = new ArrayList<Mj_Point[]>();
	public static double[][] coords;
	
	// Для отрисовки новых внешних полигонов
	public static int[][] XX;
	public static int[][] YY;
	
	public static int num_inners = 0; // Кол-во внутренних полигонов
	
	public Triangulation() {
		super("Triangulation");
		
		toolkit=Toolkit.getDefaultToolkit();
		// Получаем размеры экрана
		screenSize=toolkit.getScreenSize(); 
		// Окно не раскрывается во весь экран, но размеры окна приложения
		// соответствуют размерам экрана
		setSize(screenSize.width, screenSize.height-35);
		// Окно при запуске приложения раскрывается во весь экран
		setExtendedState(MAXIMIZED_BOTH); 
		// Минимальный размер окна граф. редактора
		setMinimumSize(new Dimension(640, 480));
		// При нажатии на "крестик" окно закрывается
		setDefaultCloseOperation(EXIT_ON_CLOSE);
		
		////////////////////////////////////////////////////
		////////////////////////////////////////////////////
		
		coords = triangulation(outer30, inners30);
//		coords = triangulation(outer31, null);
		
        ////////////////////////////////////////////////////
        ////////////////////////////////////////////////////
		
		X = new int[outer_polygon.size];
		Y = new int[outer_polygon.size];
		
		initArrayXY();
		
		initNewOuterPolygons();
		
		////////////////////////////////////////////////////
		////////////////////////////////////////////////////
		
		pp = new PaintPanel(screenSize);		
		this.add(pp);
		
		setVisible(true);
		
		System.out.println("КОНЕЦ");
	}
	
	/**
	 * Триангулирует заданный полигон.
	 * 
	 * @param P полигон для триангуляции
	 * @param h параметр, задающий размер стороны треугольника
	 * @return список треугольников
	 */
	
	private Mj_List<Mj_Polygon> contri_poly(Mj_Polygon P, double h) {
		// Избавляемся от лишних точек, лежащих на одной прямой
		P = deleteMiddlePoints(P);
		
		short cnt = 0; // Счетчик самопересеченй и измнения направления обхода полигона
		short cnt_setting  = 1; // Уставка счетчика count
		// Список треугольников, которые имеют самопересечения или изменяют направление обхода полигона
		Mj_List<Mj_Polygon> tmp_triangles = new Mj_List<>();
		// Копия заданного полигона
		Mj_Polygon copy_P = new Mj_Polygon(P);
		
		Mj_List<Mj_Polygon> LT = new Mj_List<Mj_Polygon>(); // Итоговый список треугольников
		int D = getIntDirectionOfPolygon(P); // Определяет направление обхода полигона
		
		int count = 0; // Счетчик созданных треугольников
		
		while(true) {	
			cnt = 0;
			
			Mj_Polygon triangle = null; 
			Mj_Polygon Q = new Mj_Polygon(P);
			int n = P.size();
			// Угол между двумя векторами не должен быть больше 180 градусов
			double KCI = 180.0;  
			
			for(int i = 1; i <= n; i++) {
				Mj_Vertex q1 = Q.getVertex();
				Mj_Vertex q2 = (Mj_Vertex) Q.getVertex().next();
				Mj_Vertex qn = (Mj_Vertex) Q.getVertex().prev();
				
				triangle = new Mj_Polygon();
				triangle.insert(q1.point());
				triangle.insert(q2.point());
				triangle.insert(qn.point());
				
				// Алгебраический угол м/д двумя векторами
				double FI = ang(qn.point().subtraction(q1.point()), q2.point().subtraction(q1.point()));
				
				// Определяем направление обхода треугольника (у внешнего угла знак отличается)
				// и сохраняем наименьший угол учитывая направление обхода самого полигона
				if(D > 0) {
					if((getIntDirectionOfPolygon(triangle) * FI) >= 0.0 && Math.abs(FI) < KCI) {
						if(!isContainPolygonInList(tmp_triangles, triangle) && Q.size > 3) {
							KCI = Math.abs(FI);
							P = new Mj_Polygon(Q);
						}
						
						if(!isContainPolygonInList(tmp_triangles, triangle) && Q.size == 3) {
							KCI = Math.abs(FI);
							P = new Mj_Polygon(Q);
						}
					}
				} else {
					if((getIntDirectionOfPolygon(triangle) * FI) < 0.0 && Math.abs(FI) < KCI) {
						if(!isContainPolygonInList(tmp_triangles, triangle) && Q.size > 3) {
							KCI = Math.abs(FI);
							P = new Mj_Polygon(Q);
						}
						
						if(!isContainPolygonInList(tmp_triangles, triangle) && Q.size == 3) {
							KCI = Math.abs(FI);
							P = new Mj_Polygon(Q);
						}
					}
				}
				
				Q = LCShift(Q);
			}
			
			// Если не удалась триангуляция, то изменяем настройки и пробуем снова
			if(KCI == 180 && Q.size > 3) {
				P = new Mj_Polygon(copy_P);
				LT.delete_list();
				tmp_triangles.delete_list();
				cnt_setting++;
				continue;
			}
			
			Mj_Vertex p1 = P.getVertex();
			Mj_Vertex p2 = (Mj_Vertex) P.getVertex().next();
			Mj_Vertex pn = (Mj_Vertex) P.getVertex().prev();
			
			Mj_Polygon tmp_triangle = new Mj_Polygon();
			tmp_triangle.insert(p2.point());
			tmp_triangle.insert(pn.point());
			tmp_triangle.insert(p1.point());
			
			tmp_triangles.append(tmp_triangle);
			
			// Векторы сторон полигона
			Mj_Point V = pn.point().subtraction(p1.point());
			V.x = Decompositor.round7(V.x);
			V.y = Decompositor.round7(V.y);
			
			Mj_Point W = p2.point().subtraction(p1.point());
			W.x = Decompositor.round7(W.x);
			W.y = Decompositor.round7(W.y);
			
			// Расчет целых кратностей длин сторон к числу h (округленный по верхнему целому)
			int Kv = roundUp(V.length() / h);
			int Kw = roundUp(W.length() / h);
			
			// Расчет целой кратности угла KCI к углу в 60 градусов (округленный по верхнему целому)
			int K = roundUp(KCI / 60.0);
			
			// Делаем копии полигона и списка треугольников
			Q = new Mj_Polygon(P);
			Mj_List<Mj_Polygon> QT = LT.copyList(LT);		
			
			do {
				// Вычисление векторов не превышающих значения h
				Mj_Point v = V.multiplication(1.0 / Kv);
				Mj_Point w = W.multiplication(1.0 / Kw); 
				
				// Вычисление вершин треугольников, лежащих на смежных с p1 ребрах
				Mj_Vertex a = new Mj_Vertex(p1.point().sum(v));
				a.point().x = Decompositor.round7(a.point().x);
				a.point().y = Decompositor.round7(a.point().y);
				
				Mj_Vertex b = new Mj_Vertex(p1.point().sum(w));
				b.point().x = Decompositor.round7(b.point().x);
				b.point().y = Decompositor.round7(b.point().y);
				
				// Список некратных вершин полилинии, проходящей м/д точками b и a с учетом
				// возможного совпадения точек b = p2 и a = pn
				Mj_ListVertex Lp = new Mj_ListVertex(); 
				
				for(int i = 1; i < P.size; i++)			
					Lp.append(P.advance());
				
				if(Kw != 1)
					Lp.prepend(b);
				else
					b = p2;
					
				if(Kv != 1)
					Lp.append(a);
				else
					a = pn;
				
				// Отрезок м/д точками
				Mj_Point ab = a.point().subtraction(b.point());
				ab.x = Decompositor.round7(ab.x);
				ab.y = Decompositor.round7(ab.y);
				
				// В зависимости от длины отрезка ab и коэффициента K возможны три варианта 
				// отрезания треугольников и формирования списка вершин нового полигона P
				if(ab.length() <= h || K == 1) {
					Mj_Polygon tmp_p = new Mj_Polygon();
					tmp_p.insert(new Mj_Point(Decompositor.round7(p1.point().x), 
							                  Decompositor.round7(p1.point().y)));
					tmp_p.insert(new Mj_Point(Decompositor.round7(b.point().x), 
							                  Decompositor.round7(b.point().y)));
					tmp_p.insert(new Mj_Point(Decompositor.round7(a.point().x), 
							                  Decompositor.round7(a.point().y)));
				
					LT.append(tmp_p);
					
					System.out.println(" *** Triangles " + ++count);
					
					Lp.last();
					Lp.remove();
					Lp.prepend(a);
					
					P = new Mj_Polygon(Lp.first());
					
					if(P.size < 3)
						return LT;
				} else if(K == 2) {
					double rc = ((1.0 - (1.0 / 2.0)) * v.length()) + ((1.0 / 2.0) * w.length());
					Mj_Point Nv = v.multiplication(1.0 / v.length());
					Mj_Point R = rotateMatrix(-(0.5 * D * KCI), Nv);
					
					Mj_Point u = R.multiplication(rc);
					Mj_Vertex c = new Mj_Vertex(p1.point().sum(u));
					
					Mj_Polygon tmp_p1 = new Mj_Polygon();
					tmp_p1.insert(new Mj_Point(Decompositor.round7(p1.point().x), 
							                   Decompositor.round7(p1.point().y)));
					tmp_p1.insert(new Mj_Point(Decompositor.round7(c.point().x), 
							                   Decompositor.round7(c.point().y)));
					tmp_p1.insert(new Mj_Point(Decompositor.round7(a.point().x), 
							                   Decompositor.round7(a.point().y)));
					
					Mj_Polygon tmp_p2 = new Mj_Polygon();
					tmp_p2.insert(new Mj_Point(Decompositor.round7(p1.point().x), 
							                   Decompositor.round7(p1.point().y)));
					tmp_p2.insert(new Mj_Point(Decompositor.round7(b.point().x), 
							                   Decompositor.round7(b.point().y)));
					tmp_p2.insert(new Mj_Point(Decompositor.round7(c.point().x), 
							                   Decompositor.round7(c.point().y)));
					
					LT.append(tmp_p1);
					LT.append(tmp_p2);
					
					System.out.println(" *** Triangles " + ++count);
					System.out.println(" *** Triangles " + ++count);
					
					Lp.last();
					Lp.remove();
					Lp.prepend(c);
					Lp.prepend(a);
					
					P = new Mj_Polygon(Lp.first());
				} else if(K == 3) {						
					double rd = ((1.0 - (1.0 / 3.0)) * v.length()) + ((1.0 / 3.0) * w.length());
					double re = ((1.0 - (2.0 / 3.0)) * v.length()) + ((2.0 / 3.0) * w.length());
					
					Mj_Point Nv = v.multiplication(1.0 / v.length());
					
					Mj_Point Rd = rotateMatrix(-((1.0 / 3.0) * D * KCI), Nv);
					Mj_Point Re = rotateMatrix(-((2.0 / 3.0) * D * KCI), Nv);
					
					Mj_Point ud = Rd.multiplication(rd);
					Mj_Point ue = Re.multiplication(re);
					
					Mj_Vertex d = new Mj_Vertex(p1.point().sum(ud));
					Mj_Vertex e = new Mj_Vertex(p1.point().sum(ue));
					
					Mj_Polygon tmp_p1 = new Mj_Polygon();
					tmp_p1.insert(new Mj_Point(Decompositor.round7(p1.point().x), 
							                   Decompositor.round7(p1.point().y)));
					tmp_p1.insert(new Mj_Point(Decompositor.round7(d.point().x), 
							                   Decompositor.round7(d.point().y)));
					tmp_p1.insert(new Mj_Point(Decompositor.round7(a.point().x), 
							                   Decompositor.round7(a.point().y)));
					
					Mj_Polygon tmp_p2 = new Mj_Polygon();
					tmp_p2.insert(new Mj_Point(Decompositor.round7(p1.point().x), 
							                   Decompositor.round7(p1.point().y)));
					tmp_p2.insert(new Mj_Point(Decompositor.round7(e.point().x), 
							                   Decompositor.round7(e.point().y)));
					tmp_p2.insert(new Mj_Point(Decompositor.round7(d.point().x), 
							                   Decompositor.round7(d.point().y)));
					
					Mj_Polygon tmp_p3 = new Mj_Polygon();
					tmp_p3.insert(new Mj_Point(Decompositor.round7(p1.point().x), 
							                   Decompositor.round7(p1.point().y)));
					tmp_p3.insert(new Mj_Point(Decompositor.round7(b.point().x), 
							                   Decompositor.round7(b.point().y)));
					tmp_p3.insert(new Mj_Point(Decompositor.round7(e.point().x), 
							                   Decompositor.round7(e.point().y)));
					
					LT.append(tmp_p1);
					LT.append(tmp_p2);
					LT.append(tmp_p3);
					
					System.out.println(" *** Triangles " + ++count);
					System.out.println(" *** Triangles " + ++count);
					System.out.println(" *** Triangles " + ++count);
					
					Lp.last();
					Lp.remove();
					Lp.prepend(e);
					Lp.prepend(d);
					Lp.prepend(a);
					
					P = new Mj_Polygon(Lp.first());
				}
				
				// Проверяем самопересечение полигона и направление обхода 
				// получившегося полигона (при самопересечение направление меняется)
				if((self_test(P) || D != getIntDirectionOfPolygon(P)) && cnt < cnt_setting) {
					Kv++;
					Kw++;
					cnt++;
					
					// Восстанавливаем полигон и список треугольников
					P = new Mj_Polygon(Q);
					LT = QT.copyList(QT);
				} else if(cnt >= cnt_setting) { 
					// Восстанавливаем полигон и список треугольников
					P = new Mj_Polygon(Q);
					LT = QT.copyList(QT);
					break;
				} else {
					tmp_triangles.last();
					tmp_triangles.remove();
					break;
				}
			} while(true);
		}
	}
	
	/**
	 * Ищет угол между двумя векторами, и если он равен 180 или 0 градусам, удаляет
	 * начальную вершину каждого вектора. Так проверяется каждый угол полигона.
	 * 
	 * @param p полигон
	 * @return полигон
	 */
	
	private Mj_Polygon deleteMiddlePoints(Mj_Polygon p) {
		for(int i = 1; i <= p.size; i++) {
			Mj_Vertex q1 = p.getVertex();
			Mj_Vertex q2 = (Mj_Vertex) p.getVertex().next();
			Mj_Vertex qn = (Mj_Vertex) p.getVertex().prev();
			
			// Алгебраический угол м/д двумя векторами
			double FI = ang(qn.point().subtraction(q1.point()), q2.point().subtraction(q1.point()));
			
			// Если получающийся угол м/д двумя векторами по модулю равен 180 градусам,
			// то удаляем начальную точку каждого вектора
			if(Math.abs(FI) == 180 || Math.abs(FI) == 0) {
				p.remove();
				i--;
			}
			
			p = LCShift(p);
		}
		
		// Т.к. при декомпозиции полигона на монотонные части при наличии внутренних
		// полигонов делаются разрезы для их объединения, то некоторые итоговые
		// монотонные полигоны могут иметь самопересечения
		if(self_test(p)) {
			Mj_Vertex first = p.getVertex();		
			
			int size_a = p.size - 1;
			
			for(int i = 0; i <= size_a; i++) {
				Edge a = new Edge(first.point(), ((Mj_Vertex) first.next()).point());
				Mj_Vertex third = first.cw().cw();
				
				int size_b = size_a - 1;
				
				for(int j = 1; j < size_b; j++) {
					Edge b = new Edge(third.point(), ((Mj_Vertex) third.next()).point());
				
					Intersect inter = a.cross(b, 0.0);
						
					if(inter == Intersect.SKEW_CROSS) {
						p.setVertexValue(new Mj_Vertex(b.org.x, b.org.y));
						p.remove();
						size_a = p.size - 1;
						size_b = 0;
						i = -1;
						break;
					}
					
					third = third.cw();
				}				
				first = first.cw();
			}
		}
		
		return p;
	}
	
	/**
	 * При самопересечении сторон внешнего полигона оставляет точку пересечения, а
	 * остальные точки удаляет.
	 */
	
	private void deleteIncorrectPointsInOuter() {
		boolean isCross = false; // Имеется пересечение сторон
		
		Mj_Vertex first = outer_polygon.getVertex();		
			
		int size = outer_polygon.size;
		
		for(int i = 0; i <= size - 1; i++) {
			Edge a = new Edge(first.point(), ((Mj_Vertex) first.next()).point());
			Mj_Vertex third = first.cw().cw();
				
			for(int j = 1; j < size - 2; j++) {
				Edge b = new Edge(third.point(), ((Mj_Vertex) third.next()).point());
				
				Intersect inter = a.cross(b, 0.0);
						
				if(inter == Intersect.SKEW_CROSS) {
					Mj_Vertex cross_v = getCrossingPoint(a, b);
								
					Mj_Vertex tmp1 = null;
					Mj_Vertex tmp2 = null;
					
					if(cross_v.point().equalsPoints(a.org)) {
						outer_polygon.setVertexValue(new Mj_Vertex(a.org));					
						tmp1 = outer_polygon.getVertex();
						
						outer_polygon.setVertexValue(new Mj_Vertex(b.org));
						tmp2 = outer_polygon.getVertex();
						
						tmp1.prev = tmp2;
						tmp2.next = tmp1;
					} else if(a.dest.equalsPoints(b.dest)) {
						tmp1 = ((Mj_Vertex) first.next());
						tmp2 = ((Mj_Vertex) third.next());
						// Объект для изменения координат вершин в месте пересечения
						VertexOffseter vOff = new VertexOffseter();
						
						// Смещаем координаты вершин в месте пересечения полигона так, чтобы небыло самопересечений
						vOff.offset(tmp1, tmp2, outer_polygon, 0.0000001);
					} else {
						outer_polygon.setVertexValue(new Mj_Vertex(a.org));					
						tmp1 = outer_polygon.getVertex();
						
						outer_polygon.setVertexValue(new Mj_Vertex(b.dest));
						tmp2 = outer_polygon.getVertex();
						
						tmp1.next = tmp2;
						tmp2.prev = tmp1;
					}
					
					outer_polygon.resize();
					size = outer_polygon.size;
					isCross = true;
					break;
				}
					
				third = third.cw();
			}
			
			if(isCross) {
				isCross = false;
				i = -1;
			}
				
			first = first.cw();
		}
	}
	
	/**
	 * Ищет в списке полигонов полигон с одинаковыми вершинами (координатами вершин)
	 * и количеством этих вершин в полигоне.
	 * 
	 * @param list список полигонов
	 * @param polygon полигон, который необходимо найти в списке полигонов
	 * @return TRUE, если в списке полигонов найден заданный полигон, иначе - FALSE
	 */
	
	private boolean isContainPolygonInList(Mj_List<Mj_Polygon> list, Mj_Polygon polygon) {
		// Массив для сохранения состояния равенства вершин заданного полигона и
		// полигона из списка
		boolean [] contains = new boolean[polygon.size];
		
		for(int i = 0; i < contains.length; i++)
			contains[i] = false;
		
		list.first();
		
		for(int i = 0; i < list.length(); i++, list.next()) {
			Mj_Polygon tmp_p = list.val();
			
			if(tmp_p.size == polygon.size) {
				for(int j = 0; j < polygon.size(); j++, polygon.advance()) {
					Mj_Vertex tmp_v = polygon.getVertex();
					
					for(int k = 0; k < tmp_p.size; k++, tmp_p.advance()) {
						if(tmp_v.equalsCoordsVertex(tmp_p.getVertex())) {
							contains[j] = true;
						}
					}
				}
			}
		}
		
		// Если количество вершин заданного полигона совпадает с количеством
		// состояний равенства координат вершин в одном из полигонов списка, 
		// то в списке полигонов присутствует такой же полигон (с теми же координатами), 
		// что и заданный
		short true_count = 0;
		
		for(int i = 0; i < contains.length; i++) {
			if(contains[i] == true)
				true_count++;
		}
		
		if(true_count == polygon.size())
			return true;
		
		return false;
	}
	
	/**
	 * Определяет пересечение несмежных сторон полигона. 
	 * 
	 * @param P тестируемый полигон
	 * @return TRUE, если пересечения присутствуют, иначе - FALSE
	 */
	
	private boolean self_test(Mj_Polygon P) {		
		Mj_Vertex first = P.getVertex();		
		
		for(int i = 0; i <= P.size - 1; i++) {
			Edge a = new Edge(first.point(), ((Mj_Vertex) first.next()).point());
			Mj_Vertex third = first.cw().cw();
			
			for(int j = 1; j < P.size - 2; j++) {
				Edge b = new Edge(third.point(), ((Mj_Vertex) third.next()).point());
			
				Intersect inter = a.cross(b, 0.0);
					
				if(inter == Intersect.SKEW_CROSS)
					return true;
				
				third = third.cw();
			}
			
			first = first.cw();
		}
		
		return false;
	}
	
	/**
	 * Проверяет пересечение ребра, созданного из одной точки внешнего полигона и одной
	 * точки внутреннего полигона, с любой из сторон внешнего и внутреннего полигонов.
	 * 
	 * @param edge ребро
	 * @param outer внешний полигон
	 * @param inner внутренний полигон
	 * @return TRUE, если ребро пересекает какую-либо сторону полигонов, иначе - FALSE
	 */
	
	private boolean cross_edge_test(Edge edge, Mj_Polygon outer, Mj_Polygon inner) {
		boolean isCrossOuter = false; // Признак пересечения внешнего полигона
		boolean isCrossInner = false; // Признак пересечения внутреннего полигона
		
		Mj_Vertex first_outer = outer.getVertex();
		Mj_Vertex first_inner = inner.getVertex();
		
		for(int i = 0; i < outer.size; i++) {
			Edge a = new Edge(first_outer.point(), ((Mj_Vertex) first_outer.next()).point());
			
			Intersect inter = a.cross(edge, 0.0);
			
			Point_position pp = first_outer.point().classify(edge);
			Point_position ppn = ((Mj_Vertex) first_outer.next()).point().classify(edge);
			
			if(inter == Intersect.SKEW_CROSS && pp != Point_position.ORIGIN && ppn != Point_position.ORIGIN) {
				isCrossOuter = true;
				
				break;
			}
			
			first_outer = first_outer.cw();
		}
		
		for(int i = 0; i < inner.size; i++) {
			Edge a = new Edge(first_inner.point(), ((Mj_Vertex) first_inner.next()).point());
			
			Intersect inter = a.cross(edge, 0.0);
			
			Point_position pp = first_inner.point().classify(edge);
			Point_position ppn = ((Mj_Vertex) first_inner.next()).point().classify(edge);
			
			if(inter == Intersect.SKEW_CROSS && pp != Point_position.DESTINATION && ppn != Point_position.DESTINATION) {
				isCrossInner = true;
				
				break;
			}
			
			first_inner = first_inner.cw();
		}
		
		if(isCrossOuter || isCrossInner)
			return true;
		
		return false;
	}
	
	/**
	 * Поворачивает вектор на заданный угол.
	 * 
	 * @param angle заданный угол
	 * @param v заданный вектор
	 * @return повернутый вектор
	 */
	
	private Mj_Point rotateMatrix(double angle, Mj_Point v) {
		double x = (v.x * Math.cos(Math.toRadians(angle))) - (v.y * Math.sin(Math.toRadians(angle)));
		double y = (v.x * Math.sin(Math.toRadians(angle))) + (v.y * Math.cos(Math.toRadians(angle)));
		
		return new Mj_Point(x, y);
	}
	
	/**
	 * Округляет число по верхнему целому.
	 * 
	 * @param num округляемое число
	 * @return округленное число по верхнему целому
	 */
	
	private int roundUp(double num) {
		if((num - (int) num) == 0)
			return (int) num;
		else
			return (int) num + 1;
	}
	
	/**
	 * Сдвигает текущую точку полигона на следующую. 
	 * 
	 * @param Q полигон
	 * @return новую текущую точку полигона
	 */
	
	private Mj_Polygon LCShift(Mj_Polygon Q) {
		Q.advance();
		
		return Q;
	}
	
	/**
	 * Вычисляет алгебраический угол м/д векторами
	 * 
	 * @param V вектор
	 * @param W вектор
	 * @return алгебраический угол м/д векторами
	 */
	
	private double ang(Mj_Point V, Mj_Point W) {
		return Math.toDegrees(Math.acos(((V.x * W.x) + (V.y * W.y)) / ((Math.sqrt(Math.pow(V.x, 2) + Math.pow(V.y, 2))) * (Math.sqrt(Math.pow(W.x, 2) + Math.pow(W.y, 2))))));
	}
		
	/**
	 * Функция получает на вход массив точек с координатами в формате (x, y), из которых состоит полигон.
	 * Также функция получает на вход второй аргумент в виде массива массивов точек с координатами в 
	 * формате (x, y) полигонов, которые располагаются внутри полигона, заданного в первом аргументе.
	 * В качестве второго аргумента можно задавать значение NULL. Затем функция разбивает исходный полигон 
	 * на монотонный полигон(ы) и возвращает его (их) в виде массива массивов точек с координатами в 
	 * формате (x, y).
	 * 
	 * @param outer_polygon массив точек с координатами в формате (x, y), из которых состоит полигон
	 * @param inner_polygons массив массивов точек с координатами в формате (x, y) полигонов, которые 
	 * располагаются внутри полигона, заданного в первом аргументе
	 * @return массив массивов точек с координатами в формате (x, y) монотонных полигонов либо null
	 */
	
	public double[][] triangulation(double[] outer, 
			                        double[][] inners) {	
//		middleH_fromSize(outer);
		
		if(inners != null)
			num_inners = inners.length;
		
		useOuterVertexes = new ArrayList<>(); 
		Mj_List<Mj_Polygon> inner_polys_list = new Mj_List<Mj_Polygon>(); // Внутренние полигоны, если они есть
		
		// Проверяем на четность. Если не четное кол-во координат, то 
		// полигон не удастся построить.
		if(outer.length % 2 == 0) {
			outer_polygon = makePolygon(outer); // Создаем полигон из массива
			
			// Попадаются полигоны с самопересечением (не корректные). Оставляем точки
			// пересечения, а остальное отрезаем.
			deleteIncorrectPointsInOuter();
			
			// Впихивает объект карты в экран монитора
			initScreenSize();
			
			// Проверяем наличие внутренних полигонов
			if(inners != null) {				
				// Проверяем каждый внутренний полигон на четность и заполняем список внутренних полигонов
				for(int i = 0; i < inners.length; i++) {
					if(inners[i].length % 2 == 0)
						inner_polys_list.append(makePolygon(inners[i])); 
				}				
				
				// Избавляемся от внутренних полигонов
				removeInnerPolygons(inner_polys_list);
			} else {
				// Принимаем, что изначально обход от вершины к вершине полигона по часовой стрелке
				boolean outer_CW = getBoolDirectionOfPolygonVertexes(outer_polygon); 
				
				// Если обход вершин полигона против часовой стрелки, то меняем его на обратный
				if(!outer_CW) {
					outer_polygon.changeCircumventPoints();
					outer_CW = true; 
				}
			}
		}
		
		// Декомпозиция полигона на монотонные части
		monotone_polygons = decompositor.regularize(outer_polygon);
		
		// Вычисляем среднее значение параметра h
//		middleH_fromEdge();
		
		useOuterVertexes = null;
		inner_polys_list = null;
		// Триангуляция монотонных полигонов
		return getTriangleArray();
//		return null;
	}
	
	/**
	 * Вычисляет габаритный параметр для рассчета стороны треугольника при триангуляции,
	 * как среднее от самого большого и самого маленького ребер полигона.
	 */
	
	private void middleH_fromEdge() {
		double min_length = 0, max_length = 0;
		
		if(monotone_polygons != null && monotone_polygons.length() > 0) {
			monotone_polygons.first();
			
			for(int i = 0; i < monotone_polygons.length(); i++) {
				Mj_Polygon p = monotone_polygons.val();
				
				for(int j = 0; j < p.size; j++) {
					double length = ((Mj_Vertex) p.getVertex().next()).point().subtraction(p.getVertex().point()).length();
					
					if(i == 0 && j == 0) {
						min_length = length;
						max_length = length;
					}
					
					if(length > max_length)
						max_length = length;
					
					if(length < min_length)
						min_length = length;
										
					p.advance();
				}
				
				monotone_polygons.next();
			}
		}
		
		h = (min_length + max_length) / 2;
		
//		System.out.println("Min L = " + min_length + ", Max L = " + max_length + ", H = " + h);
	}
	
	/**
	 * Вычисляет габаритный параметр для рассчета стороны треугольника при триангуляции,
	 * как половина длины от стороны ограничивающего объект карты прямоугольника.
	 * 
	 * @param outer массив координат внешнего полигона
	 */
	
	private void middleH_fromSize(double[] outer) {		
		JRect bounds = new JRect(); // Ограничивающий объект карты прямоугольник
		
		// Долгота (ось X) точек объекта карты
		double [] lon_x_outer = new double[outer.length / 2];
		
		for(int i = 0, j = 0; i < outer.length; i+=2, j++)
			lon_x_outer[j] = outer[i];
		
			
		// Широта (ось Y) точек объекта карты
		double [] lat_y_outer = new double[outer.length / 2];
		
		for(int i = 1, j = 0; i <= outer.length; i+=2, j++)
			lat_y_outer[j] = outer[i];
		
		// Создаем геометрическую фигуру полигона из точек объекта карты
		JPolygon polygon = new JPolygon(lon_x_outer, lat_y_outer, lon_x_outer.length);
		
		// Получаем от полигона его ограничивающий пряоугольник, но т.к. ось Y полигона напрвленна
		// вверх и широта изменяется также, а ось Y у прямоугольника направлена вниз, то меняем 
		// друг с другом координаты top и bottom в возвращаемом ограничивающем прямоугольнике
		bounds = polygon.getBounds(); // Ось Y вверх
			
		h = bounds.width / 2;
		
//		System.out.println("Min L = " + min_length + ", Max L = " + max_length + ", H = " + h);
	}
	
	/**
	 * Выполняет триангуляцию монотонных полигонов из списка и возвращает 
	 * список треугольников в виде массива массивов с координатами. Координаты
	 * треугольников храняться в виде: array_1 = {x1,y1, x2,y2, x3,y3}.
	 * 
	 * 
	 * @return список треугольников в виде массива массивов с координатами
	 */
	
	private double[][] getTriangleArray() {
		if(monotone_polygons != null && monotone_polygons.length() > 0) {
			monotone_polygons.first();
		
			for(int i = 0; i < monotone_polygons.length(); i++) {
				boolean outer_CW = getBoolDirectionOfPolygonVertexes(monotone_polygons.val());
				// Возвращает полигонам оригинальные (изначальные) координаты вершин,
				// которые менялись при приращении и повороте
				decompositor.returnOriginalViewAfterSplit(monotone_polygons.val());
				
				// Если обход вершин полигона по часовой стрелке, то меняем его на обратный
				if(outer_CW) {
					monotone_polygons.val().changeCircumventPoints();
					outer_CW = false; 
				}
				
				triangles.append(contri_poly(monotone_polygons.val(), h));
				monotone_polygons.next();
			}			
//			return null;
			return getArraysCoords();
		} else
			return null;
	}
	
	/**
	 * Сортирует вершины в порядке увеличения координаты X.
	 * 
	 * @param p полигон
	 * @param cmp идентификатор направления оси X (влево или вправо)
	 * @return массив отсортированных вершин
	 */
	
	private Mj_Vertex[] buildSchedule(Mj_Polygon p, Scaning cmp) {
		Mj_Vertex[] schedule = new Mj_Vertex[p.size];
		
		for(int i = 0; i < p.size; i++, p.advance(Rotation.CLOCKWISE)) {
			schedule[i] = p.getVertex();
		}
		
		insertionSort(schedule, p.size, cmp);
		
		return schedule;
	}
	
	/**
	 * Сортирует элементы в массиве от меньшего к большему.
	 * 
	 * @param a массив
	 * @param n кол-во элементов массива для сортировки
	 */
	
	private void insertionSort(Mj_Vertex[] a, int n, Scaning cmp) {
		for(int i = 0; i < n - 1; i++) {
			int min = i;
			
			for(int j = i + 1; j < n; j++) {
				switch(cmp) {
				case LEFT_TO_RIGHT:
					if(CompareFunc.leftToRightCmp(a[j], a[min]) < 0)
						min = j;
					break;
				case RIGHT_TO_LEFT:
					if(CompareFunc.rightToLeftCmp(a[j], a[min]) < 0)
						min = j;
					break;
				}
			}
			
			a = swap(a, i, min);
		}
	}
	
	/**
	 * Выполняет взаимную замену значений в массиве вершин для указаных ей двух индексов.
	 * 
	 * @param a массив вершин
	 * @param i первый индекс
	 * @param min второй индекс
	 * @return измененный массив вершин
	 */
	
	private Mj_Vertex[] swap(Mj_Vertex[] a, int i, int min) {
		Mj_Vertex v = a[i];
		
		a[i] = a[min];
		a[min] = v;
		
		return a;
	}
	
	/**
	 * Преобразует координаты вершин треугольников в массив массивов.
	 * 
	 * @return массив массивов с координатами
	 */
	
	private double[][] getArraysCoords() {
		double[][] arraysCoords = new double[triangles.length()][];
		
		triangles.first();
		
		for(int i = 0; i < triangles.length(); i++) {
			Mj_Polygon p = triangles.val();
			
			double[] tmp = new double[p.size * 2];
			
			for(int j = 0; j < p.size * 2; j+=2) {
				arraysCoords[i] = tmp;
				
				tmp[j] = p.point().x;
				tmp[j + 1] = p.point().y;	
				
				p.advance();
			}
			
			triangles.next();
		}
		
		triangles.delete_list();
		
		return arraysCoords;
	}
	
	/**
	 * Если полигон содержит в себе внутренние полигоны, то эта функция избавляется
	 * от них. В итоге получаются полигон без внутренних полигонов. Сначала проверяем 
	 * внутренние полигоны на наличие стороны (сторон), которые коллинеарны (одинаковы) стороне (сторонам) 
	 * внешнего полигона, и если такие есть, то объединяем внутренний полигон с внешним, а коллинерные 
	 * ребра (стороны у внутреннего и внешнего полигонов) удаляем.  Далее берем каждую точку внешнего 
	 * полигона и ищем самую ближнею точку какого-нибудь внутреннего полигона. Когда находим, то проверяем 
	 * направление обхода внешнего полигона, сравниваем с направлением обхода внутреннего полигона, 
	 * которому принадлежит найденная точка, если надо, меняем направление обхода внутреннего
	 * полигона. Затем делаем расщепление по двум точкам и остается только внешний полигон.
	 * 
	 * @param inner_polys_list внутренние полигоны
	 */
	
	private void removeInnerPolygons(Mj_List<Mj_Polygon> inner_polys_list) {	
		// Объединяем внутренние полигоны, если они имеют одинаковые ребра (стороны)
		inner_polys_list = sortInnerPolygons(inner_polys_list);
				
		int size = inner_polys_list.length(); // Размер списка внутренних полигонов
		
		inner_polys_list.first(); // Переходим на первый полигон в списке
		
		// Избавляемся от внутренних полигонов стороны которых лежат на сторонах внешнего полигона
		for(int i = 0; i < size; i++) {						
			// Проверяем наличие внутренних полигонов, сторона(ы) которого лежит на
			// стороне(ах) внешнего полигона
			if(checkAndUnionInnerSides(inner_polys_list.val())) {
				inner_polys_list.remove();
			} 
			
			inner_polys_list.next();
		}
			
		inner_polys_list.first(); // Переходим на первый полигон в списке
		size = inner_polys_list.length(); // Размер списка внутренних полигонов
		
		for(int i = 0; i < size; i++) {
			// Находим внутренний полигон наиболее близко расположенный к внешнему
			inner_polys_list.val(getPolygonWithMinDistance(inner_polys_list));
			// Объединяем два полигона в один внешний 
			// полигон, который объединили с внешним
			unionPolygons(inner_polys_list.remove());	
		}
	}
	
	/**
	 * Сортирует список внутренних полигонов на отдельные ни чем с друг
	 * другом не свзанные. Это может быть один независимый полигон, 
	 * либо группа из нескольих полигонов имеющих общие стороны.
	 * 
	 * @param list список внутренних полигонов
	 * @return список отсортированных внутренних полигонов
	 */
	
	private Mj_List<Mj_Polygon> sortInnerPolygons(Mj_List<Mj_Polygon> list) {
		// Список отсортированых полигонов
		ArrayList<ArrayList<Mj_Polygon>> sortInnerPolygons = new ArrayList<ArrayList<Mj_Polygon>>();
		// Первоначальный список полигонов (не отсортированных)
		ArrayList<Mj_Polygon> allInnersPolygons = new ArrayList<>();
		// Признак того, что один полигон имеет хотябы одну общую сторону с другим
		boolean isBelong = false;
		
		list.first();
		
		// Для удобства работы переводим полигоны из списка одного типа в список другого типа
		for(int p = 0; p < list.length(); p++) {
			allInnersPolygons.add(list.val());
			list.next();
		}
		
		if(allInnersPolygons.size() == 1) {
			sortInnerPolygons.add(allInnersPolygons);
		} else {
			int size = allInnersPolygons.size() - 1;
			
			for(int p = 0; p < size; p++) {
				isBelong = false;
				
				// Первый в списке полигон
				Mj_Polygon first_inner_polygon = allInnersPolygons.get(p);
										
				// Направление обхода вершин в первом в списке внутреннем полигоне
				boolean first_CW = getBoolDirectionOfPolygonVertexes(first_inner_polygon);
										
				// Если обход вершин полигона против часовой стрелки, то меняем его на обратны
				if(!first_CW) {
					first_inner_polygon.changeCircumventPoints();
					first_CW = true; 
				}
				
				// Временный полигон для хранения полигонов с общими сторонами
				ArrayList<Mj_Polygon> tmpList = new ArrayList<>();
				
				for(int p2 = 1; p2 < allInnersPolygons.size(); p2++) {
					// Следующий за первым в списке полигон
					Mj_Polygon next_inner_polygon = allInnersPolygons.get(p2);
											
					// Направление обхода вершин в следующем внутреннем полигоне
					boolean next_CW = getBoolDirectionOfPolygonVertexes(next_inner_polygon);
					
					if(first_CW != next_CW) {
						next_inner_polygon.changeCircumventPoints();
						next_CW = true;
					}
					
					// Ищем в полигонах одинаковые ребра
					int next_size = next_inner_polygon.size;
								
					for(int i = 0; i < next_size; i++) {
						Edge next_inner_edge = next_inner_polygon.edge();
						
						for(int j = 0; j < first_inner_polygon.size; j++) {
							Edge first_inner_edge = first_inner_polygon.edge();
										
							Intersect intersect = next_inner_edge.intersect(first_inner_edge, 0.0);
										
							if(intersect == Intersect.COLLINEAR) {
								if(first_inner_edge.org.equalsPoints(next_inner_edge.dest) && 
								   first_inner_edge.dest.equalsPoints(next_inner_edge.org)) {
									isBelong = true;
									
									if(!tmpList.contains(next_inner_polygon))
										tmpList.add(next_inner_polygon);
								}
							}
							first_inner_polygon.advance();
						}
						next_inner_polygon.advance();
					}
				}
				
				if(isBelong) {
					tmpList.add(first_inner_polygon);
					sortInnerPolygons.add(tmpList);
					
					for(int n = 0; n < tmpList.size(); n++)
						allInnersPolygons.remove(tmpList.get(n));
					
					size = allInnersPolygons.size() - 1;
					p = -1;
				} else {
					tmpList.add(first_inner_polygon);
					sortInnerPolygons.add(tmpList);
					
					allInnersPolygons.remove(first_inner_polygon);
					size = allInnersPolygons.size() - 1;
					p = -1;
					
					// Если все полигоны перебрали, а один остался, то
					// т.к. он не имеет коллинеарных сторон, добавляем его
					// к окончательному списку
					if(allInnersPolygons.size() == 1)
						sortInnerPolygons.add(allInnersPolygons);
				}
			}
		}
		
		// Очищаем заданный список
		list.delete_list();
		
		// Теперь отсортированные полигоны с общими сторонами (при наличии) объединяем 
		// друг с другом и заполняем заданный список новыми полигонами
		list = unionInnerPolygons(sortInnerPolygons);
		
		return list;
	}
	
	/**
	 * Проверяет полигон на замыкание, т.е. не имеет ли полигон одного общего
	 * ребра (стороны). При наличии общего ребра соединяет полигон по крайним точкам
	 * этого ребра, в результате чего получаем два новых полигона: внутренний и внешний.
	 * Внешний полигон возвращаем, а внутренний полигон заносим в спиок новых полигонов карты.
	 * 
	 * @param P полигон для проверки
	 * @return новый полигон
	 */
	
	private Mj_Polygon testPolygon(Mj_Polygon P) {
		boolean self = self_test(P);
		boolean check = true;
		
		while(self){			
			if(check) {
				Mj_Vertex first = P.getVertex();
				
				int size = P.size;
				
				for(int i = 0; i < size - 1; i++) {
					Edge a = new Edge(first.point(), ((Mj_Vertex) first.next()).point());
					Mj_Vertex third = first.cw().cw();
				
					for(int j = 0; j < size - 2; j++) {
						Edge b = new Edge(third.point(), ((Mj_Vertex) third.next()).point());
					
						Intersect intersect = a.intersect(b, 0.0);
					
						if(intersect == Intersect.COLLINEAR) {							
							if(a.org.equalsPoints(b.dest) && b.org.equalsPoints(a.dest)) {
								Mj_Polygon copy_polygon1 = new Mj_Polygon(P);
								Mj_Polygon copy_polygon2 = new Mj_Polygon(P);
								
								Mj_Vertex [] first_orgs = copy_polygon1.setVertexValueToArray(copy_polygon1.setVertexValue(new Mj_Vertex(a.org)));
								Mj_Vertex [] next_orgs = copy_polygon2.setVertexValueToArray(copy_polygon2.setVertexValue(new Mj_Vertex(b.org)));
								
								// Объединяем два полигона для создания двух новых полигонов
								copy_polygon1.setVertex(first_orgs[0]);
								first_orgs[0].splice((Mj_Vertex) first_orgs[1]);
								copy_polygon1.resize();
								
								copy_polygon2.setVertex(next_orgs[1]);
								next_orgs[1].splice((Mj_Vertex) next_orgs[0]);
								copy_polygon2.resize();
								
								// Попределяем какой из двух получившихся полигонов внутренний, 
								// а какой станет новым внешним полигоном
								// У кого площать по модулю больше, тот внутренний полигон
								double sum1 = Math.abs(copy_polygon1.getAreaOfPolygon());
								double sum2 = Math.abs(copy_polygon2.getAreaOfPolygon());
								
								if(sum1 > sum2) {
									outerPolysAfterUnionInnersPolys.append(copy_polygon2);
									P = copy_polygon1;
									P.resize();
								} else {
									outerPolysAfterUnionInnersPolys.append(copy_polygon1);
									P = copy_polygon2;
									P.resize();
								}
								
								self = self_test(P);
								
								if(!self)
									check = false;
								break;
							}
						}
						third = third.cw();
					}
					first = first.cw();
					
					if(!check && !self) 
						break;
				}
			}
		}
		
    	return P;
    }
	
	/**
	 * Проверяет полигоны на коллинеарные (одинаковые) ребра и, если такие имеются, 
	 * объединяет полигоны по крайним точкам одинаковых ребер. В итоге, получается 
	 * один полигон.
	 * 
	 * @param first_inner_polygon этот полигон будет результативным полигоном после объединения
	 * @param next_inner_polygon этот полигон сливается с предыдущим и больше не используется
	 */
	
	private void testEdges(Mj_Polygon first_inner_polygon, Mj_Polygon next_inner_polygon) {	
		// Крайние точки одинаковых ребер двух полигонов
		Mj_Vertex first_point1 = null;
		Mj_Vertex next_point1 = null;
		Mj_Vertex first_point2 = null;
		Mj_Vertex next_point2 = null;
		
		// Проверяем не является ли это цепочкой последовательно коллинеарных ребер
		boolean stop = false;
		boolean reverse = false;
		Edge tmp_first_inner_edge = null;
		Edge tmp_next_inner_edge = null;
		
		while(!stop) {
			if(!reverse) {
				first_inner_polygon.setVertex(first_inner_polygon.ccw());
				tmp_first_inner_edge = first_inner_polygon.edge();
				
				next_inner_polygon.setVertex(next_inner_polygon.cw());
				tmp_next_inner_edge = next_inner_polygon.edge();
			} else {
				first_inner_polygon.setVertex(first_inner_polygon.cw());
				tmp_first_inner_edge = first_inner_polygon.edge();
				
				next_inner_polygon.setVertex(next_inner_polygon.ccw());
				tmp_next_inner_edge = next_inner_polygon.edge();
			}						
			
			Intersect tmp_intersect = tmp_next_inner_edge.intersect(tmp_first_inner_edge, 0.0);
			
			if(!(tmp_intersect == Intersect.COLLINEAR && 
			   (tmp_first_inner_edge.org.equalsPoints(tmp_next_inner_edge.dest) && 
				tmp_first_inner_edge.dest.equalsPoints(tmp_next_inner_edge.org)))) {				
				if(!reverse) {
					first_inner_polygon.setVertex(first_inner_polygon.cw());
					next_inner_polygon.setVertex(next_inner_polygon.ccw());
					
					first_point1 = first_inner_polygon.getVertex();
					next_point1 = next_inner_polygon.getVertex();
					
					reverse = true;
				} else {
					first_inner_polygon.setVertex(first_inner_polygon.ccw());
					next_inner_polygon.setVertex(next_inner_polygon.cw());
					
					first_point2 = first_inner_polygon.getVertex();
					next_point2 = next_inner_polygon.getVertex();
					
					reverse = false;
				}
			}
			
			if(first_point1 != null && next_point1 != null && first_point2 != null && next_point2 != null)
				stop = true;
		}
		
		if(first_point1.equalsVertex(first_point2) && next_point1.equalsVertex(next_point2)) {
			Mj_Vertex tmp = (Mj_Vertex) first_point1.next.next;
			
			first_point1.next = next_point1.next.next;
			next_point1.next.next.prev = first_point1;
			
			first_inner_polygon.setVertex((Mj_Vertex) first_point2.next);
			
			tmp.prev = next_point1;
			next_point1.next = tmp;
		} else {
			first_point1.next = next_point1.next.next;
			next_point1.next.next.prev = first_point1;
			
			first_inner_polygon.setVertex((Mj_Vertex) first_point2.next);
			
			first_point2.next.prev = next_point2.prev;
			next_point2.prev.next = first_point2.next;
		}	
		
		first_inner_polygon.resize();
	}
	
	/**
	 * Объединяет полигоны имеющие коллинеарные (одинаковые) стороны в один общий
	 * полигон, а также, если получившийся один полигон также имеет общие стороны
	 * (замкнут сам на себя), то создает два новых полигона. 
	 * 
	 * @param list список полигонов с коолинеарными (одинаковыми) сторонами
	 * @return список полигонов
	 */
	
	private Mj_List<Mj_Polygon> unionInnerPolygons(ArrayList<ArrayList<Mj_Polygon>> list) {
		// Итоговый список внутренних полигонов
		Mj_List<Mj_Polygon> inner_polys = new Mj_List<Mj_Polygon>();
		ArrayList<Mj_Polygon> tmpList = null;
		
		for(int l = 0; l < list.size(); l++) {
			tmpList = list.get(l);
			
			if(tmpList.size() == 1) {
				Mj_Polygon tmpPolygon = testPolygon(tmpList.get(0));
				
				inner_polys.append(tmpPolygon);
			} else {
				int size = tmpList.size() - 1;
				
				for(int p = 0; p < size; p++) {
					// Первый в списке полигон
					Mj_Polygon first_inner_polygon = tmpList.get(p);
					
					for(int p2 = 1; p2 < tmpList.size(); p2++) {
						// Следующий за первым в списке полигон
						Mj_Polygon next_inner_polygon = tmpList.get(p2);
						
						// Ищем в полигонах одинаковые ребра
						int next_size = next_inner_polygon.size;
						
						for(int i = 0; i < next_size; i++) {
							Edge next_inner_edge = next_inner_polygon.edge();
							
							for(int j = 0; j < first_inner_polygon.size; j++) {
								Edge first_inner_edge = first_inner_polygon.edge();
								
								Intersect intersect = next_inner_edge.intersect(first_inner_edge, 0.0);
								
								if(intersect == Intersect.COLLINEAR) {
									if(first_inner_edge.org.equalsPoints(next_inner_edge.dest) && 
									   first_inner_edge.dest.equalsPoints(next_inner_edge.org)) {
										testEdges(first_inner_polygon, next_inner_polygon);	
										
										tmpList.remove(next_inner_polygon);
										next_size = 0;
										size = tmpList.size() - 1;
										p = -1;										
										
										if(tmpList.size() < 2) { 
											first_inner_polygon = testPolygon(first_inner_polygon);
											
											tmpList.clear();
											tmpList.add(first_inner_polygon);
										} 
										
										break;
									}
								}
								first_inner_polygon.advance();
							}
							next_inner_polygon.advance();
						}
					}
				}
				inner_polys.append(tmpList.get(0));
			}
		}
			
		return inner_polys;
	}
	
	/**
	 * Проверяет принадлежность какой-либо стороны внутреннего полигона стороне(ам)
	 * внешнего полигона.
	 * 
	 * @param inner_polygon внутренний полигон
	 * @return TRUE, если одна или несколько сторон внутреннего полигона принадлежат
	 *  стороне(ам) внешнего полигона, иначе - FALSE
	 */
	
	private boolean checkAndUnionInnerSides(Mj_Polygon inner_polygon) {
		boolean isCheck = false; // Признак коллинеарности ребер (одинаковые стороны у полигонов)
		// Список ребер внешнего полигона
		ArrayList<Edge> outer_edges = new ArrayList<>(0); 
		// Список ребер внутрреннего полигона
		ArrayList<Edge> inner_edges = new ArrayList<>(0); 
		// Список не коллинеарных ребер внешнего и внутрреннего полигонов
		ArrayList<Edge> edges = new ArrayList<>(0); 
		// Список коллинеарных ребер внешнего и внутрреннего полигонов
		ArrayList<Edge> collinear_edges = new ArrayList<>(0); 
		
		// Направление обхода вершин во внешнем полигоне
		boolean outer_CW = getBoolDirectionOfPolygonVertexes(outer_polygon); 
		// Направление обхода вершин во внутреннем полигоне
		boolean inner_CW = getBoolDirectionOfPolygonVertexes(inner_polygon);
					
		// Если обход вершин полигона против часовой стрелки, то меняем его на обратный
		if(!outer_CW) {
			outer_polygon.changeCircumventPoints();
			outer_CW = true; 
		}
					
		// Если направления обхода вершин полигонов не совпадают, то меняем направление обхода
		// у внутреннего полигона на противоположное
		if(outer_CW != inner_CW) {
			inner_polygon.changeCircumventPoints();
			inner_CW = true;
		}
		
		// Получаем ребра, из которых состоят полионы
		outer_edges = outer_polygon.getEdgesOfPolygon(outer_polygon);
		inner_edges = inner_polygon.getEdgesOfPolygon(inner_polygon);
		
		// Ищем в полигонах одинаковые ребра
		for(int i = 0; i < inner_edges.size(); i++) {
			Edge inner_edge = inner_edges.get(i);
			
			for(int j = 0; j < outer_edges.size(); j++) {
				Edge outer_edge = outer_edges.get(j);
				
				Intersect intersect = inner_edge.intersect(outer_edge, 0.0);
				
				if(intersect == Intersect.COLLINEAR) {
					if(outer_edge.org.equalsPoints(inner_edge.org) && outer_edge.dest.equalsPoints(inner_edge.dest)) {
						collinear_edges.add(inner_edge);
						
						isCheck = true;
					} 
				}
			}
		}
		
		if(collinear_edges.size() != 0) {
			// Создаем общий список ребер внешнего и внутреннего полигонов без их коллинеарных сторон
			// Для внутреннего полигона			
			for(int i = 0; i < collinear_edges.size(); i++) {
				Edge coll_edge = collinear_edges.get(i);
				
				for(int j = 0; j < inner_edges.size(); j++) {
					Edge inner_edge = inner_edges.get(j);
					
					if(inner_edge.equalsEdges(coll_edge)) {
						inner_edges.remove(j);
						j = -1;	
					}
				}
			}
			// Для внешнего полигона			
			for(int i = 0; i < collinear_edges.size(); i++) {
				Edge coll_edge = collinear_edges.get(i);
				
				for(int j = 0; j < outer_edges.size(); j++) {
					Edge outer_edge = outer_edges.get(j);
					
					if(outer_edge.equalsEdges(coll_edge)) {
						outer_edges.remove(j);
						j = -1;	
					}
				}
			}
			
			// Инвертируем направление ребер
			for(int i = 0, j = 0; i < inner_edges.size(); i++) {
				Edge e = inner_edges.remove(j);
				e.changeCircumventPoints();
				inner_edges.add(e);
			}
			
			// Объединяем списки ребер полигонов в один общий список
			edges.addAll(outer_edges);
			edges.addAll(inner_edges);
			
			// Ищем у ребер общие точки и объединяем их в полигон(ы)
			ArrayList<Mj_Polygon> res_poly = createPolygonsFromEdges(edges);
			
			// Если в результате получился один полигон, то делаем его внешним полигоном,
			// но если в результате получилось больше одного полигона, то первый полигон
			// в списке делаем внешним, а остальные помещаем в список внешних полигонов,
			// получившихся после объединения с внутренними полигонами
			if(res_poly.size() == 1) {
				outer_polygon = null;
				outer_polygon = res_poly.get(0);
			} else if(res_poly.size() > 1) {
				outer_polygon = null;
				outer_polygon = res_poly.get(0);
				
				for(int i = 1; i < res_poly.size(); i++) {
					outerPolysAfterUnionInnersPolys.append(res_poly.get(i));
				}
			}
		}
		
		return isCheck;
	}
	
	/**
	 * Из списка отдельных ребер создает замкнутые полигоны.
	 * 
	 * @param edges список ребер
	 * @return список оттдельных полигонов
	 */
	
	private ArrayList<Mj_Polygon> createPolygonsFromEdges(ArrayList<Edge> edges) {
		ArrayList<Mj_Polygon> polys = new ArrayList<>(1);
		ArrayList<Edge> tmp_edges = new ArrayList<>();
		
		if(edges.size() > 0) {
			tmp_edges.add(edges.remove(0));
			
			Mj_Point org = tmp_edges.get(0).org;
			Mj_Point dest = tmp_edges.get(tmp_edges.size() - 1).dest;
			
			for(int i = 0; i < edges.size(); i++) {
				if(tmp_edges.size() == 1) {
					if(org.equalsPoints(edges.get(i).dest)) {
						tmp_edges.add(0, edges.remove(i));
						org = tmp_edges.get(0).org;
						i = -1;
					} else if(dest.equalsPoints(edges.get(i).org)) {
						tmp_edges.add(edges.remove(i));
						dest = tmp_edges.get(tmp_edges.size() - 1).dest;
						i = -1;
					}
				} else {
					if(dest.equalsPoints(edges.get(i).org) && !org.equalsPoints(edges.get(i).dest)) {
						tmp_edges.add(edges.remove(i));
						dest = tmp_edges.get(tmp_edges.size() - 1).dest;
						i = -1;
					} else if(org.equalsPoints(edges.get(i).dest) && !dest.equalsPoints(edges.get(i).org)) {
						tmp_edges.add(0, edges.remove(i));
						org = tmp_edges.get(0).org;
						i = -1;
					} else if(dest.equalsPoints(edges.get(i).org) && org.equalsPoints(edges.get(i).dest)) {
						tmp_edges.add(edges.remove(i));
						
						// Создаем новый полигон
						// Координаты полигона
						double [] coords = new double[tmp_edges.size() * 2];
						
						for(int j = 0, k = 0; j < tmp_edges.size(); j++, k+=2) {
							coords[k] = tmp_edges.get(j).org.x;
							coords[k + 1] = tmp_edges.get(j).org.y;
						}
						
						polys.add(makePolygon(coords));
						
						tmp_edges.clear();
						
						if(edges.size() > 0) {
							tmp_edges.add(edges.remove(0));
							
							org = tmp_edges.get(0).org;
							dest = tmp_edges.get(tmp_edges.size() - 1).dest;
						}
						
						i = -1;
					}
				}
			}
		}
				
		return polys;
	}
	
	/**
	 * Объединяет внешний полигон с внутренним. В итоге получается один внешний полигон.
	 * 
	 * @param inner_polygon внутренний полигон
	 */ 
	
	private void unionPolygons(Mj_Polygon inner_polygon) {
		// Направление обхода вершин во внешнем полигоне
		boolean outer_CW = getBoolDirectionOfPolygonVertexes(outer_polygon); 
		// Направление обхода вершин во внутреннем полигоне
		boolean inner_CW = getBoolDirectionOfPolygonVertexes(inner_polygon);
				
		// Если обход вершин полигона против часовой стрелки, то меняем его на обратный
		if(!outer_CW) {
			outer_polygon.changeCircumventPoints();
			outer_CW = true; 
		}
				
		// Если направления обхода вершин полигонов совпадают, то меняем направление обхода
		// у внутреннего полигона на противоположное
		if(outer_CW == inner_CW) {
			inner_polygon.changeCircumventPoints();
			inner_CW = false;
		}
					
		// Разрезает внешний полигон по двум точкам (наиближайшие точки внешнего и внутреннего
		// полигонов), при этом создает их дубликаты. В итоге, внутренний полигон становится 
		// частью внешнего.
//		outer_polygon.getVertex().split_triangle(inner_polygon.getVertex(), outer_CW, outer_polygon);
		
		outer_polygon.getVertex().split_and_offset_triangle(inner_polygon.getVertex(), outer_CW, outer_polygon);
		
		// Изменяем размер полигона
//		outer_polygon.resize();
		
		System.out.println("SelfTest: " + self_test(outer_polygon));
	}
	
	/**
	 * Определяет направление обхода от точки к следующей точки в полигоне.
	 * 
	 * @param polygon полигон
	 * @return TRUE, если обход осуществляется по часовой стрелке, иначе - FALSE 
	 */
	
	private boolean getBoolDirectionOfPolygonVertexes(Mj_Polygon polygon) {
		// Принимаем, что изначально обход от вершины к вершине полигона по часовой стрелке
		boolean CW = true; 
		
		// Вычисляем площадь полигона
		double S = polygon.getAreaOfPolygon();
		
		// Если площадь полигона больше нуля, то обход вершин совершается против часовой стрелки
		if(S > 0)
			CW = false;
		
		return CW;
	}
	
	/**
	 * Ищет значение координат точки пересечения двух отрезков.
	 * 
	 * @param a первый отрезок
	 * @param b второй отрезок
	 * @return вершина с координатами точки пересечения заданных отрезков
	 */
	
	private Mj_Vertex getCrossingPoint(Edge a, Edge b) {
		Mj_Vertex v = null;
		double EPS = 1e-9; // Бесконечно малая величина (как ноль)	
		
		// Находим коэффициенты прямой для первого отрезка
		double a1 = a.dest.y - a.org.y; 
		double b1 = a.org.x - a.dest.x;
		double c1 = (a.org.x * (a.org.y - a.dest.y)) + (a.org.y * (a.dest.x - a.org.x));
		
		// Находим коэффициенты прямой для второго отрезка
		double a2 = b.dest.y - b.org.y; 
		double b2 = b.org.x - b.dest.x;
		double c2 = (b.org.x * (b.org.y - b.dest.y)) + (b.org.y * (b.dest.x - b.org.x));
		
		// Находим точку пересечения двух прямых
		
		// Ищем знаменатель, чтобы сразу понять пересекаются прямые или нет
		double znamenatel = (a1 * b2) - (a2 * b1);
		
		// Если знаменатель равен нулю или стремиться к нему, то прямые не пересекаются, иначе ...
		if(!(Math.abs(znamenatel) == 0)) {
			double chislitel_x = (c1 * b2) - (c2 * b1);
			double chislitel_y = (a1 * c2) - (a2 * c1);
			
			// Точка пересечения
			double res_x = (- (chislitel_x / znamenatel));
			double res_y = (- (chislitel_y / znamenatel));
			res_x = Decompositor.round7(res_x);
			res_y = Decompositor.round7(res_y);
			
			v = new Mj_Vertex(res_x, res_y);
		}
		
		return v;
	}
	
	/**
	 * Определяет направление обхода от точки к следующей точки в полигоне.
	 * 
	 * @param P полигон
	 * @return -1, если направление обхода по часовой стрелке, 1 - против часовой стрелки, иначе 0
	 */
	
	private int getIntDirectionOfPolygon(Mj_Polygon P) {
		// Вычисляем площадь полигона
		double S = P.getAreaOfPolygon();
		
		if(S > 0)
			return 1; // Против часовой стрелки 
		else if(S < 0)
			return -1; // По часовой стрелке 
		else
			return 0; 
	}
	
	/**
	 * Находит внутренний полигон, который ближе всего расположен к какой-то вершине внешнего полигона.
	 * 
	 * @param outer_polygon внешний полигон
	 * @param inner_polys_list список внутренних полигонов
	 * @return внутренний полигон, который ближе всего расположен к какой-то вершине внешнего полигона
	 */
	
	private Mj_Polygon getPolygonWithMinDistance(Mj_List<Mj_Polygon> inner_polys_list) {
		double minDistance = 0; // Минимальное расстояние между двумя точками	
		int min_count = -1; // Индекс наиближайшего внутреннего полигона в списке внутренних полигонов 
		Mj_Vertex minVertex = null; // Вершина внутреннего полигона ближе всех расположенная к внешнему полигону
		boolean isFirstMin = false; // Флаг того, что была рассчитана в первый (начальная) раз минимальная дистанция м/д точками 
		
		// Сортируем вершины полигона слева на право
		Mj_Vertex[] outer_schedule = buildSchedule(outer_polygon, Scaning.LEFT_TO_RIGHT);
		Mj_Polygon inner = null; // Первый внутренний полигон списка		
		
		for(int i = 0; i < outer_schedule.length; i++) {
			inner = inner_polys_list.first();
			
			for(int j = 0; j < inner_polys_list.length(); j++) {
				// Сортируем вершины полигона слева на право
				Mj_Vertex[] inner_schedule = buildSchedule(inner, Scaning.LEFT_TO_RIGHT);
				
				for(int k = 0; k < inner_schedule.length; k++) {
					if(!isUse(outer_schedule[i])) { 
						double min = getDistanceBetweenVertexes(outer_schedule[i], inner_schedule[k]);
					
						if(!isFirstMin) {
							if(!cross_edge_test(new Edge(outer_schedule[i].point(), inner_schedule[k].point()), 
									            outer_polygon, inner)) {
								minDistance = min;
								min_count = j;
								minVertex = inner_schedule[k];
								outer_polygon.setVertex(outer_schedule[i]);
								
								isFirstMin = true;
							}							
						} else {
							if(min < minDistance) {
								if(!cross_edge_test(new Edge(outer_schedule[i].point(), inner_schedule[k].point()), 
							                        outer_polygon, inner)) {
									minDistance = min;
									min_count = j;
									minVertex = inner_schedule[k];
									outer_polygon.setVertex(outer_schedule[i]);
								}
								
							}
						}
					}
				}
				
				inner = inner_polys_list.next();
			}
		}
		
		inner_polys_list.first(); // Перемещаем окно списка на первого члена списка
		
		// Ищем нужный внутренний полигон
		for(int i = 0; i < min_count; i++) {
			inner_polys_list.next();
		}
		
		// Ищем вершину во внутреннем полигоне наиближайшую к внешнему полигону
		for(int j = 0; j < inner_polys_list.val().size; j++) {
			if(inner_polys_list.val().getVertex().equalsVertex(minVertex)) {
				inner_polys_list.val().setVertex(minVertex);
				break;
			}
			
			inner_polys_list.val().advance();
		}
		
		return inner_polys_list.val();
	}
	
	/**
	 * Проверяет вершину полигона на использование ранее в разрезании полигона
	 * при объединении внешнего полигона с внутренним
	 * 
	 * @param v вершина полигона
	 * @return TRUE, если вершина ранее уже использовалась, иначе - FALSE
	 */
	
	private boolean isUse(Mj_Vertex v) {
		for(int i = 0; i < useOuterVertexes.size(); i++) {
			Mj_Vertex tmp_v = useOuterVertexes.get(i);
			
			if(tmp_v.point().x == v.point().x && tmp_v.point().y == v.point().y)
				return true;
		} 
		
		return false;
	}
	
	/**
	 * Вычисляет расстояние между двумя вершинами по их координатам.
	 * 
	 * @param v1 первая вершина
	 * @param v2 вторая вершина
	 * @return расстояние между двумя вершинами
	 */
	
	private double getDistanceBetweenVertexes(Mj_Vertex v1, Mj_Vertex v2) {
		return Math.sqrt(Math.pow((v2.point().x - v1.point().x), 2) + Math.pow((v2.point().y - v1.point().y), 2));
	}
	
	/**
	 * Создает полигон по заданному массиву координат.
	 * 
	 * @param array массив координат
	 * @return полигон либо null
	 */
	
	private Mj_Polygon makePolygon(double[] array) {
		if(array.length % 2 == 0) {
			Mj_Point[] p_outer = getPointsArray(array);
			Mj_Vertex[] v_array = getVertexesArray(p_outer);
		
			Mj_ListVertex v_list = new Mj_ListVertex();
			v_list = v_list.arrayToList(v_array, v_array.length);
		
			return new Mj_Polygon(v_list.first());
		}
		
		return null;
	}
	
	/**
	 * Создает массив точек из заданноко списка координат.
	 * 
	 * @param array массив координат
	 * @return массив точек
	 */
	
	private Mj_Point[] getPointsArray(double[] array) {
		Mj_Point[] points = new Mj_Point[array.length / 2];
		
		for(int i = 0, j = 0; i < points.length; i++, j += 2)
			points[i] = new Mj_Point(array[j], array[j + 1]);
		
		return points;
	}
	
	/**
	 * Создает массив вершин из заданноко списка точек.
	 * 
	 * @param array массив точек
	 * @return массив вершин
	 */
	
	private Mj_Vertex[] getVertexesArray(Mj_Point[] array) {
		Mj_Vertex[] vertexes = new Mj_Vertex[array.length];
		
		for(int i = 0; i < array.length; i++)
			vertexes[i] = new Mj_Vertex(array[i]);
		
		return vertexes;
	}
	
	private void initScreenSize() {
		for(int i = 0; i < outer_polygon.size; i ++) {			
			screenLocation((int) convertToSphericalMercatorFromLongetude(outer_polygon.getVertex().point().x),
	                       (int) convertToSphericalMercatorFromLatitude(outer_polygon.getVertex().point().y));
		
			outer_polygon.setVertex(outer_polygon.getVertex().cw());
		}
	}
	
	/**
	 * Используется для автоматического вывода объекта карты на экран.
	 * 
	 * @param x координата
	 * @param y координата
	 */
	
	private void screenLocation(int x, int y) {
		if(!isFirst) {
			minLon = x;
			maxLon = x;
			minLat = y;
			maxLat = y;
			
			isFirst = true;
		} else {
			if(x < minLon)
				minLon = x - 10;
			
			if(x > maxLon)
				maxLon = x + 15;
			
			if(y < minLat)
				minLat = y - 10;
			
			if(y > maxLat)
				maxLat = y + 15;
		}
		
	}
	
	private void initNewOuterPolygons() {
		if(outerPolysAfterUnionInnersPolys.length() > 0) {
			XX = new int[outerPolysAfterUnionInnersPolys.length()][];
			YY = new int[outerPolysAfterUnionInnersPolys.length()][];
			
			outerPolysAfterUnionInnersPolys.first();
			
			for(int i = 0; i < outerPolysAfterUnionInnersPolys.length(); i++) {
				Mj_Polygon p = outerPolysAfterUnionInnersPolys.val();
				
				int[] tmp_x = new int[p.size];
				int[] tmp_y = new int[p.size];
				
				for(int j = 0; j < p.size; j++) {					
					tmp_x[j] = (int) this.convertToScreenCoordsLongetude(convertToSphericalMercatorFromLongetude(p.getVertex().point().x));
					tmp_y[j] =(int) this.convertToScreenCoordsLatitude(convertToSphericalMercatorFromLatitude(p.getVertex().point().y));
					
					p.advance();
				}
				
				XX[i] = tmp_x;
				YY[i] = tmp_y;
				
				outerPolysAfterUnionInnersPolys.next();
			}
		}		
	}
	
	/**
	 * Преобразует координаты полученных треугольников в экранные координаты
	 */
	
	private void initArrayXY() {		
		for(int i = 0; i < outer_polygon.size; i++) {	
			X[i] = (int) this.convertToScreenCoordsLongetude(convertToSphericalMercatorFromLongetude(outer_polygon.getVertex().point().x));
			Y[i] = (int) this.convertToScreenCoordsLatitude(convertToSphericalMercatorFromLatitude(outer_polygon.getVertex().point().y));
			
			outer_polygon.advance();
		}
		
		if(monotone_polygons != null) {
			monotone_polygons.first();
			
			for(int i = 0; i < monotone_polygons.length(); i++) {
				Mj_Polygon p = monotone_polygons.val();
				Mj_Point [] pt = new Mj_Point[p.size];
				
				for(int j = 0; j < p.size; j++) {
					pt[j] = new Mj_Point(this.convertToScreenCoordsLongetude(convertToSphericalMercatorFromLongetude(p.getVertex().point().x)), 
				                         this.convertToScreenCoordsLatitude(convertToSphericalMercatorFromLatitude(p.getVertex().point().y)));
					
					p.setVertex(p.getVertex().cw());
				}
				
				arrayPolygonPoints.add(pt);
				monotone_polygons.next();
			}
		}
		
		if(triangles.length() != 0) {
			triangles.first();
			
			for(int i = 0; i < triangles.length(); i++) {
				Mj_Polygon p = triangles.val();
				Mj_Point [] pt = new Mj_Point[p.size];
				
				for(int j = 0; j < p.size; j++) {
					pt[j] = new Mj_Point(this.convertToScreenCoordsLongetude(convertToSphericalMercatorFromLongetude(p.getVertex().point().x)), 
							             this.convertToScreenCoordsLatitude(convertToSphericalMercatorFromLatitude(p.getVertex().point().y)));
					p.setVertex(p.getVertex().cw());
				}
				
				arrayTrianglesPoints.add(pt);
				triangles.next();
			}
		}
	}
	
	/**
     * Преобразовывает значение широты (в градусах) в линейное значение (координата y).
     *
     * @param latitude значение широты (в градусах)
     * @return значение широты (линейные координаты)
     */

    public synchronized double convertToSphericalMercatorFromLatitude(double latitude) {
        return (R * Math.log(Math.tan((Math.PI / 4.0) + (((latitude * Math.PI) / 180.0) / 2.0))));
    }

    /**
     * Преобразовывает значение долготы (в градусах) в линейное значение (координата x).
     * Результат получается в виде вещественного числа.
     *
     * @param longetude значение долготы (в градусах)
     * @return значение долготы (линейные координаты)
     */

    public synchronized double convertToSphericalMercatorFromLongetude(double longetude) {
        return (R * ((longetude * Math.PI) / 180.0));
    }
    
    /**
     * Преобразовывает линейное значение (координата y) широты точки местоположения
     * пользователя в экранные координаты.
     *
     * @param y линейное значение (координата y) широты точки местоположения пользователя
     * @return экранные координаты значения широты точки местоположения пользователя
     */

    public synchronized double convertToScreenCoordsLatitude(double y) {
        return (((y - minLat) / (maxLat  - minLat)) * (20 - 710)) + 710;
    }

    /**
     * Преобразовывает линейное значение (координата x) долготы точки местоположения
     * пользователя в экранные координаты.
     *
     * @param x линейное значение (координата x) долготы точки местоположения пользователя
     * @return экранные координаты значения долготы точки местоположения пользователя
     */

    public synchronized double convertToScreenCoordsLongetude(double x) {
        return (((x - minLon) / (maxLon - minLon)) * (1366 - 10)) + 0;
    }
    	
    // Точка запуска приложения
	public static void main(String[] args) {
		// Запуск приложения в потоке обработки событий
		SwingUtilities.invokeLater(new Runnable() {
		
			@Override
			public void run() {
				// Устанавливаем внешний вид приложения
				try {
					UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
				} catch (ClassNotFoundException | InstantiationException
						| IllegalAccessException | UnsupportedLookAndFeelException e) {
					e.printStackTrace();
				}
				
				new Triangulation();
			}
		});		
	}
}

// Класс для отрисовки полученных треугольников
class PaintPanel extends JPanel {
	
	private static final long serialVersionUID = 1L;
	private Polygon p;
	private Random rand = new Random();

	public PaintPanel(Dimension size) {
		this.setOpaque(true);
		this.setPreferredSize(size);
		
		p = new Polygon();
	}
	
	public void paintComponent(Graphics g) {
		super.paintComponent(g);		
		Graphics2D g2=(Graphics2D)g;
		
		// Изначальный полигон
/*		g2.setColor(Color.BLACK);
		g2.setStroke(new BasicStroke(1.0f));
		g2.drawPolygon(Triangulation.X, Triangulation.Y, Triangulation.Y.length);
		
		g2.setStroke(new BasicStroke(1.0f));*/
		
		// Новые внешние полигоны
		if(Triangulation.outerPolysAfterUnionInnersPolys.length() > 0) {
			g2.setColor(Color.BLUE);
			g2.setStroke(new BasicStroke(1.0f));
			
			for(int i = 0; i < Triangulation.outerPolysAfterUnionInnersPolys.length(); i++) {
				g2.drawPolygon(Triangulation.XX[i], Triangulation.YY[i], Triangulation.YY[i].length);
			}		
			
			g2.setStroke(new BasicStroke(1.0f));
		}		
		
		// Получившиеся полигоны
/*		for(int i = 0; i < Triangulation.arrayPolygonPoints.size(); i++) {			
			g2.setColor(new Color(rand.nextInt(255), rand.nextInt(255), rand.nextInt(255), 200));
			
			int[] x = getArrayX(Triangulation.arrayPolygonPoints.get(i));
			int[] y = getArrayY(Triangulation.arrayPolygonPoints.get(i));
			
			g2.fillPolygon(x, y, y.length);
		}
		
		g2.setColor(Color.BLACK);
		g2.setFont(new Font(null, 0, 20));
		g2.drawString("Monotone polygons: " + Triangulation.arrayPolygonPoints.size(), 10, 30);*/
		
		// Получившиеся треугольники
/*		for(int i = 0; i < Triangulation.arrayTrianglesPoints.size(); i++) {			
			g2.setColor(new Color(rand.nextInt(255), rand.nextInt(255), rand.nextInt(255), 200));
			
			int[] x = getArrayX(Triangulation.arrayTrianglesPoints.get(i));
			int[] y = getArrayY(Triangulation.arrayTrianglesPoints.get(i));
			
			g2.fillPolygon(x, y, y.length);
		}*/
		
		
		// Получившиеся треугольники из массива массивов
		for(int i = 0; i < Triangulation.coords.length; i++) {			
			g2.setColor(new Color(rand.nextInt(255), rand.nextInt(255), rand.nextInt(255), 200));
			g2.setColor(new Color(225, 125, 125, 200));
			
			int[] x = getCoordsArrayX(Triangulation.coords[i]);
			int[] y = getCoordsArrayY(Triangulation.coords[i]);
			
			g2.fillPolygon(x, y, y.length);
		}
		
		g2.setColor(Color.BLACK);
		g2.setFont(new Font(null, 0, 20));
		g2.drawString("Inner polygons: " + Triangulation.num_inners, 10, 30);
		g2.drawString("Monotone polygons: " + Triangulation.arrayPolygonPoints.size(), 10, 60);
		g2.drawString("Triangles (list): " + Triangulation.arrayTrianglesPoints.size(), 10, 90);
		g2.drawString("Triangles (array): " + Triangulation.coords.length, 10, 120);
		g2.drawString("H = " + Triangulation.h, 10, 150);
		g2.drawString("New polygons: " + Triangulation.outerPolysAfterUnionInnersPolys.length(), 10, 180);
		
		// Все точки
/*		g2.setColor(Color.RED);
		g2.setStroke(new BasicStroke(4.0f));
		
		for(int i = 0; i < Triangulation.X.length; i++)
			g2.drawLine(Triangulation.X[i], Triangulation.Y[i], Triangulation.X[i], Triangulation.Y[i]);*/
	}
	
	private int[] getCoordsArrayX(double[] p) {
		int[] tmp = new int[p.length / 2];
		
		for(int i = 0, j = 0; i < tmp.length; i++, j +=2)
				tmp[i] = (int) convertToScreenCoordsLongetude(convertToSphericalMercatorFromLongetude(p[j]));
		
		return tmp;
	}
	
	private int[] getCoordsArrayY(double[] p) {
		int[] tmp = new int[p.length / 2];
		
		for(int i = 0, j = 1; i < tmp.length; i++, j +=2)
				tmp[i] = (int) convertToScreenCoordsLatitude(convertToSphericalMercatorFromLatitude(p[j]));
		
		return tmp;
	}
	
	private int[] getIntArray(double[] array) {
		int[] tmp = new int[array.length];
		
		for(int i = 0; i < array.length; i++)
			tmp[i] = (int)array[i];
		
		return tmp;
	}
	
	private int[] getArrayX(Mj_Point[] p) {
		int[] tmp = new int[p.length];
		
		for(int i = 0; i < p.length; i++)
			tmp[i] = (int) p[i].x;
		
		return tmp;
	}
	
	private int[] getArrayY(Mj_Point[] p) {
		int[] tmp = new int[p.length];
		
		for(int i = 0; i < p.length; i++)
			tmp[i] = (int) p[i].y;
		
		return tmp;
	}
	
	/**
     * Преобразовывает значение широты (в градусах) в линейное значение (координата y).
     *
     * @param latitude значение широты (в градусах)
     * @return значение широты (линейные координаты)
     */

    public synchronized double convertToSphericalMercatorFromLatitude(double latitude) {
        return (Triangulation.R * Math.log(Math.tan((Math.PI / 4.0) + (((latitude * Math.PI) / 180.0) / 2.0))));
    }

    /**
     * Преобразовывает значение долготы (в градусах) в линейное значение (координата x).
     * Результат получается в виде вещественного числа.
     *
     * @param longetude значение долготы (в градусах)
     * @return значение долготы (линейные координаты)
     */

    public synchronized double convertToSphericalMercatorFromLongetude(double longetude) {
        return (Triangulation.R * ((longetude * Math.PI) / 180.0));
    }
    
    /**
     * Преобразовывает линейное значение (координата y) широты точки местоположения
     * пользователя в экранные координаты.
     *
     * @param y линейное значение (координата y) широты точки местоположения пользователя
     * @return экранные координаты значения широты точки местоположения пользователя
     */

    public synchronized double convertToScreenCoordsLatitude(double y) {
        return (((y - Triangulation.minLat) / (Triangulation.maxLat  - Triangulation.minLat)) * (20 - 710)) + 710;
    }

    /**
     * Преобразовывает линейное значение (координата x) долготы точки местоположения
     * пользователя в экранные координаты.
     *
     * @param x линейное значение (координата x) долготы точки местоположения пользователя
     * @return экранные координаты значения долготы точки местоположения пользователя
     */

    public synchronized double convertToScreenCoordsLongetude(double x) {
        return (((x - Triangulation.minLon) / (Triangulation.maxLon - Triangulation.minLon)) * (1366 - 10)) + 0;
    }
}


